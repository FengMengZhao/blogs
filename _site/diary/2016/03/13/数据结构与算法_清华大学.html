<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>麦羞 - 数据结构与算法_清华大学</title>
  <meta name="author" content="麦羞" />
  <meta name="description" content="The blog of 麦羞" />
  <link rel="canonical" href="/blogs/diary/2016/03/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6.html" />
  <!-- <script type="text/javascript" src="//use.typekit.net/jxo0xyj.js"></script> -->
  <!-- <script type="text/javascript">try{Typekit.load();}catch(e){}</script> -->
  <link href="//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700,800" rel="stylesheet" type="text/css">
  <link rel="shortcut icon" href="/blogs/assets/images/favicon.png">
  <link rel="alternate" type="application/rss+xml" title="麦羞" href="/blogs/atom.xml" />
  <link rel="stylesheet" href="/blogs/assets/css/all.css">
  <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.min.css">
</head>
<body>
  <div class="container">
    <div class="four columns sidebar">
      <nav>
  <h1>博客</h1>
  <a href="/">
      <img src="/blogs/assets/images/fmz-logo2.png" id="logo" alt="Blog logo"/>
  </a>
  <h2>@ <a href="/blogs/resume">麦羞</a>.</h2>
  <hr/>
  <ul>
  <p>在这里我分享我的每一步成长 </p>
  <p>
    我是一名在读研究生
  </p>
  <hr/>
  <div>
    <div id="social">
      Follow me:
<div id="stalker">
  
  <a title="FengMengZhao on Github" href="https://github.com/FengMengZhao">
    <i class="fa fa-github-square"></i>
  </a>
  

  
  <a title="fengmengzhao on Twitter" href="https://twitter.com/fengmengzhao">
    <i class="fa fa-twitter-square"></i>
  </a>
  

  
  <a title="麦羞 on Facebook" href="https://facebook.com/100008350779619">
    <i class="fa fa-facebook-square"></i>
  </a>
  

  
  <a title="麦羞 on Google Plus" href="https://plus.google.com/105478354193409781551">
    <i class="fa fa-google-plus-square"></i>
  </a>
  

</div>

    </div>
  </div>
  </ul>
</nav>

    </div>

    <div class="eleven columns content">
        <p class="meta">
  March 13, 2016
  <a href="/">
    <i class="home fa fa-home"></i>
  </a>
</p>

<h1 class="title">数据结构与算法_清华大学</h1>

<div id="post">
  <h2 id="目录">目录</h2>

<ul>
  <li><a href="#1">1 绪论</a></li>
  <li><a href="#2">2 Array-Based</a>
    <ul>
      <li><a href="#2.1">2.1 向量(Vector)</a></li>
      <li><a href="#2.2">2.2 堆(Heap)</a></li>
    </ul>
  </li>
  <li><a href="#3">3 sequence-based</a>
    <ul>
      <li><a href="#3.1">3.1 栈(Stack)</a></li>
      <li><a href="#3.2">3.2 队列(Queue)</a></li>
      <li><a href="#3.3">3.3 双向队列(Deque)</a></li>
      <li><a href="#3.4">3.4 通用二叉树(General Binary Tree)</a></li>
      <li><a href="#3.5">3.5 Binary Search Tree</a></li>
    </ul>
  </li>
</ul>

<hr />

<hr />

<h2 id="1">1 绪论</h2>

<p><strong>学习结构的本质</strong></p>

<ol>
  <li>把数据结构图形化、视觉化、</li>
  <li>学习什么时候用什么样的数据结构和算法</li>
</ol>

<blockquote>
  <p>Computer science should be called computing science, for the same reason why surgery is not called knife science.</p>
</blockquote>

<p><strong>HailStoneSequence算法</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 基本的HailStone序列
 * 当n=1时，算法停止
 * 当n为大于1的偶数时，除以2，加入序列
 * 当n为大于1的奇数时，n*3+1，加入序列
 * 重复上面两部，知道算法停止(n=1) 
 */
import java.util.* ;

public class HailStoneSquence{
	static List hailStoneSquence(int n){
		List list = new ArrayList() ;
		list.add(n) ;
		while(1 &lt; n){
			n = (n % 2 != 0) ? 3*n+1 : n/2 ;
			list.add(n) ;
		}
		return list ;
	}

	public static void main(String args[]){
		for(int i=1;i&lt;100;i++){
			List list = hailStoneSquence(i) ;
			System.out.println(list) ;
		}
	}
}
</code></pre></div></div>

<p><strong>好算法：</strong></p>

<ul>
  <li>正确
    <ul>
      <li>能够正确处理简单的数据</li>
      <li>能够正确处理大规模的输入</li>
      <li>能够正确处理一般性的输入</li>
      <li>能够正确处理退化的输入</li>
      <li>能够正确处理任意合法的输入</li>
    </ul>
  </li>
  <li>健壮
    <ul>
      <li>能够辨别出不合法的输入并做恰当的处理，而不至于非正常退出</li>
    </ul>
  </li>
  <li>可读
    <ul>
      <li>结构化+准确命名+注释+…</li>
    </ul>
  </li>
  <li>效率
    <ul>
      <li>Algorithm + Data Structure = Programs</li>
      <li>(Algorithm + Data Structure) X Efficiency = Computation</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>To measure is to know, If you can not measure it, you can not improve it.</p>
</blockquote>

<h3 id="算法记号">算法记号</h3>

<blockquote>
  <p>通常考虑问题的规模足够大的情况下，问题的成本(执行的基本操作次数)如何增长</p>
</blockquote>

<p><strong>级数</strong></p>

<p>算数级数：与末项平方同阶</p>

<p>T(n) = 1 + 2 + 3 + … + n = n(n+1)/2 = O(n²)</p>

<p>幂方级数：比幂次高出一阶</p>

<p>T(n) = 1² + 2² + … + n² = n(n+1)(2n+1)/6 = O(n³)</p>

<p>T(n) = 1³ + 2³ + 3³ + … + n³ = n²(n+1)²/4 = O(n^4)</p>

<p>几何级数(a&gt;1)：与末项同阶</p>

<p>T(n) = aº + a¹ + a² + … + a^n = O(a^n)</p>

<p>特殊的：</p>

<p>h(n) = 1 + 1/2 + 1/3 + … + 1/n = Θ(logn)，调和级数</p>

<p>h(n) = log1 + log2 + log3 + … + logn = log(n!) = Θ(nlogn)，对数级数</p>

<p><strong>经典冒泡排序算法</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">经典的冒泡排序算法</span>
 <span class="p">*</span> <span class="err">不断进行循环，进行第</span><span class="n">i</span><span class="err">次循环时将第</span><span class="n">i</span><span class="err">大的元素放在序列的倒数第</span><span class="n">i</span><span class="err">位</span>
 <span class="p">*</span> <span class="err">只要在循环内有元素的位置交换，用</span><span class="n">boolean</span><span class="err">变量记录，还需进行循环</span>
 <span class="p">*</span> <span class="n">boolean</span><span class="err">标识是关键，当我们再进行循环的时候，如果发现没有可交换的元素，表明序列已经排列好，就不再进行循环，退出</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">dsa</span><span class="p">.</span><span class="n">first</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">BubbleSort</span><span class="p">{</span>

	<span class="n">void</span> <span class="n">bubbleSort</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">){</span>
		<span class="n">for</span><span class="p">(</span><span class="k">boolean</span> <span class="n">flag</span> <span class="p">=</span> <span class="nb">false</span><span class="p">;</span> <span class="n">flag</span> <span class="p">=</span> <span class="c1">!flag; n--){
</span>			<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">n</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
				<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]){</span>
					<span class="n">int</span> <span class="n">exchange</span> <span class="p">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
					<span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">;</span>
					<span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">exchange</span> <span class="p">;</span>
					<span class="n">flag</span> <span class="p">=</span> <span class="nb">false</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>	
	<span class="p">}</span>

	<span class="n">void</span> <span class="n">bubbleSort2</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">){</span>
		<span class="k">boolean</span> <span class="n">sorted</span> <span class="p">=</span> <span class="nb">false</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">sorted</span> <span class="p">=</span> <span class="c1">!sorted){
</span>			<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">n</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
				<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]){</span>
					<span class="n">int</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
					<span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">;</span>
					<span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span> <span class="p">;</span>
					<span class="n">sorted</span> <span class="p">=</span> <span class="nb">false</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">n</span> <span class="p">--</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">BubbleSort</span> <span class="n">bs</span> <span class="p">=</span> <span class="n">new</span> <span class="n">BubbleSort</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">int</span><span class="p">[]</span> <span class="n">A</span> <span class="p">=</span> <span class="p">{</span><span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">}</span> <span class="p">;</span>
		<span class="p">//</span><span class="n">bs</span><span class="p">.</span><span class="n">bubbleSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">bs</span><span class="p">.</span><span class="n">bubbleSort2</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">;</span>

		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">a</span> <span class="p">:</span> <span class="n">A</span><span class="p">){</span>
			<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="s2">"</span><span class="se">\t</span><span class="s2">"</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}/*</span> <span class="n">output</span><span class="p">:</span>
<span class="m">1</span>	<span class="m">2</span>	<span class="m">2</span>	<span class="m">3</span>	<span class="m">4</span>	<span class="m">4</span>	<span class="m">5</span>	<span class="m">5</span>	<span class="m">6</span>	<span class="m">7</span>	<span class="p">[</span><span class="n">Finished</span> <span class="k">in</span> <span class="m">0.6</span><span class="n">s</span><span class="p">]</span>
<span class="p">*/</span>
</code></pre></div></div>

<blockquote>
  <p>冒泡排序算法写法是在是太经典了，用两层for循环或者一层while循环一层for循环即可实现。</p>
</blockquote>

<h3 id="迭代和递归">迭代和递归</h3>

<blockquote>
  <p>迭代乃人工，递归方神通(To iterate is human, to recurse, divine)</p>
</blockquote>

<blockquote>
  <p>凡治众如治寡，分数是也(The control of a large force is the principle as the control of a few men:it is merely a question of dividing up their numbers)</p>
</blockquote>

<p><strong>Decrese-and-conquer，减而治之</strong></p>

<p>求解一个大规模的问题，可以将其分为两个子问题：其中一个”平凡”，另一个规模缩减，分别求解子问题，由子问题的解得到原问题的解。</p>

<p>减而治之——经典例子：求解一个数组的和</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">将求和问题分解为一个规模缩减的子问题和一个平凡的问题</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">dsa</span><span class="p">.</span><span class="n">first</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">SumArray</span><span class="p">{</span>

	<span class="n">int</span> <span class="k">sum</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">n</span><span class="p">){</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">n</span> <span class="p">&lt;</span> <span class="m">1</span><span class="p">)</span> <span class="p">?</span>
			<span class="m">0</span> <span class="p">:</span> <span class="k">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">n</span><span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="n">A</span><span class="p">[</span><span class="n">n</span><span class="p">-</span><span class="m">1</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span>
	
	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">int</span><span class="p">[]</span> <span class="n">A</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">}</span> <span class="p">;</span>

		<span class="n">SumArray</span> <span class="n">sa</span> <span class="p">=</span> <span class="n">new</span> <span class="n">SumArray</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">int</span> <span class="k">sum</span> <span class="p">=</span> <span class="n">sa</span><span class="p">.</span><span class="k">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">;</span>
		<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="k">sum</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}/*</span> <span class="n">output</span><span class="p">:</span>
<span class="m">15</span>
<span class="p">*/</span>
</code></pre></div></div>

<p>减而治之——经典例子：数组倒置</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">将问题分解成一个规模小的子问题和一个平凡的问题</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">dsa</span><span class="p">.</span><span class="n">first</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">ReverseArray</span><span class="p">{</span>
	<span class="n">private</span> <span class="n">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">lo</span><span class="p">,</span> <span class="n">int</span> <span class="n">hi</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">A</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">A</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="p">=</span> <span class="n">A</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">A</span><span class="p">[</span><span class="n">hi</span><span class="p">]</span> <span class="p">=</span> <span class="n">temp</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">void</span> <span class="nb">reverse</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">lo</span><span class="p">,</span> <span class="n">int</span> <span class="n">hi</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">lo</span> <span class="p">&lt;</span> <span class="n">hi</span><span class="p">){</span>
			<span class="n">this</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span> <span class="p">;</span>
			<span class="nb">reverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lo</span><span class="p">+</span><span class="m">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">return</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">int</span><span class="p">[]</span> <span class="n">A</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">}</span> <span class="p">;</span>
		<span class="n">ReverseArray</span> <span class="n">ra</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ReverseArray</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">ra</span><span class="p">.</span><span class="nb">reverse</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">;</span>

		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">a</span> <span class="p">:</span> <span class="n">A</span><span class="p">){</span>
			<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="s2">"</span><span class="se">\t</span><span class="s2">"</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}/*</span> <span class="n">output</span><span class="p">:</span>
<span class="m">6</span>       <span class="m">5</span>       <span class="m">4</span>       <span class="m">7</span>       <span class="m">3</span>       <span class="m">2</span>       <span class="m">5</span>       <span class="m">1</span>
<span class="p">*/</span>
</code></pre></div></div>

<p><strong>Divide-and-conquer，分而治之</strong></p>

<p>为求解一个大规模的问题，可以将其划分为若干个(通常两个)子问题，规模大体相当，分别求解子问题，由子问题的解得到原问题的解。</p>

<p>分而治之——经典例子：数组求和</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">将问题分解成两个规模相当的子问题</span>
 <span class="p">*</span> <span class="err">递归基是求解子问题的基础</span>
 <span class="p">*</span> <span class="err">子问题求解、合并</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">dsa</span><span class="p">.</span><span class="n">first</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">SumArray2</span><span class="p">{</span>
	
	<span class="n">int</span> <span class="k">sum</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">lo</span><span class="p">,</span> <span class="n">int</span> <span class="n">hi</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">lo</span> <span class="p">==</span> <span class="n">hi</span><span class="p">){</span>
			<span class="n">return</span> <span class="n">A</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">int</span> <span class="n">m</span> <span class="p">=</span> <span class="p">(</span><span class="n">lo</span> <span class="p">+</span> <span class="n">hi</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span> <span class="p">;</span>
			<span class="n">return</span> <span class="k">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">+</span> <span class="k">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">m</span><span class="p">+</span><span class="m">1</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">int</span><span class="p">[]</span> <span class="n">A</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">}</span> <span class="p">;</span>
		<span class="n">SumArray2</span> <span class="n">sa2</span> <span class="p">=</span> <span class="n">new</span> <span class="n">SumArray2</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">int</span> <span class="k">sum</span> <span class="p">=</span> <span class="n">sa2</span><span class="p">.</span><span class="k">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">;</span>
		<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="k">sum</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}/*</span> <span class="n">output</span><span class="p">:</span>
<span class="m">21</span>
<span class="p">*/</span>
</code></pre></div></div>

<p>分而治之——经典例子：从数组中找出最大的两个数</p>

<p>实现一：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">先找出序列当中的最大数并记录</span><span class="n">max_index</span>
 <span class="p">*</span> <span class="err">从</span><span class="n">index</span><span class="err">将序列分为前后两部分</span>
 <span class="p">*</span> <span class="err">依次在其中找出</span><span class="n">sub_index</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">dsa</span><span class="p">.</span><span class="n">first</span> <span class="p">;</span>

<span class="n">class</span> <span class="n">MyResult</span><span class="p">{</span>
	<span class="n">private</span> <span class="n">int</span> <span class="n">max_index</span> <span class="p">;</span>
	<span class="n">private</span> <span class="n">int</span> <span class="n">sub_max_index</span> <span class="p">;</span>

	<span class="k">public</span> <span class="n">MyResult</span><span class="p">(</span><span class="n">int</span> <span class="n">max_index</span><span class="p">,</span> <span class="n">int</span> <span class="n">sub_max_index</span><span class="p">){</span>
		<span class="n">this</span><span class="p">.</span><span class="n">max_index</span> <span class="p">=</span> <span class="n">max_index</span> <span class="p">;</span>
		<span class="n">this</span><span class="p">.</span><span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">sub_max_index</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">int</span> <span class="n">getMaxIndex</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">this</span><span class="p">.</span><span class="n">max_index</span> <span class="p">;</span>
	<span class="p">}</span>
	<span class="k">public</span> <span class="n">int</span> <span class="n">getSubMaxIndex</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">this</span><span class="p">.</span><span class="n">sub_max_index</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">FindTwoMax</span><span class="p">{</span>

	<span class="n">MyResult</span> <span class="k">max</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">lo</span><span class="p">,</span> <span class="n">int</span> <span class="n">hi</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">max_index</span> <span class="p">=</span> <span class="n">lo</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">lo</span><span class="p">+</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">max_index</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
				<span class="n">max_index</span> <span class="p">=</span> <span class="n">i</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">int</span> <span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">lo</span><span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">lo</span><span class="p">+</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">max_index</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">sub_max_index</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
				<span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">i</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">max_index</span><span class="p">+</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">sub_max_index</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
				<span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">i</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">return</span> <span class="n">new</span> <span class="n">MyResult</span><span class="p">(</span><span class="n">max_index</span><span class="p">,</span> <span class="n">sub_max_index</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">FindTwoMax</span> <span class="n">ftm</span> <span class="p">=</span> <span class="n">new</span> <span class="n">FindTwoMax</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">int</span><span class="p">[]</span> <span class="n">A</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">9</span><span class="p">}</span> <span class="p">;</span>
		<span class="n">MyResult</span> <span class="n">mr</span> <span class="p">=</span> <span class="n">ftm</span><span class="p">.</span><span class="k">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">;</span>
		<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"max_index: "</span> <span class="p">+</span> <span class="n">mr</span><span class="p">.</span><span class="n">getMaxIndex</span><span class="p">()</span> <span class="p">+</span> <span class="s2">" sub_max_index: "</span> <span class="p">+</span> <span class="n">mr</span><span class="p">.</span><span class="n">getSubMaxIndex</span><span class="p">())</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>当一个方法中要输出两个结果的时候，我们可以对这两个结果进行封装，封装成一个类，这样就可以返回多个值</p>
</blockquote>

<p>实现二：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">一个对象保存</span><span class="n">max_index</span><span class="err">和</span><span class="n">sub_index</span>
 <span class="p">*</span> <span class="err">对象遍历整个序列，对于序列中的每一个数，更新</span><span class="n">max_index</span><span class="err">和</span><span class="n">sub_index</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">dsa</span><span class="p">.</span><span class="n">first</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">FindTwoMax2</span><span class="p">{</span>
	<span class="n">MyResult</span> <span class="k">max</span><span class="p">(</span><span class="n">int</span><span class="p">[]</span> <span class="n">A</span><span class="p">,</span> <span class="n">int</span> <span class="n">lo</span><span class="p">,</span> <span class="n">int</span> <span class="n">hi</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">max_index</span> <span class="p">=</span> <span class="n">lo</span><span class="p">;</span>
		<span class="n">int</span> <span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">lo</span><span class="p">+</span><span class="m">1</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">lo</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">lo</span><span class="p">+</span><span class="m">1</span><span class="p">]){</span>
			<span class="n">max_index</span> <span class="p">=</span> <span class="n">lo</span><span class="p">+</span><span class="m">1</span> <span class="p">;</span>
			<span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">lo</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="n">lo</span><span class="p">+</span><span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">hi</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">sub_max_index</span><span class="p">]){</span>
				<span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">i</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">max_index</span><span class="p">]){</span>
					<span class="n">sub_max_index</span> <span class="p">=</span> <span class="n">max_index</span> <span class="p">;</span>
					<span class="n">max_index</span> <span class="p">=</span> <span class="n">i</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">return</span> <span class="n">new</span> <span class="n">MyResult</span><span class="p">(</span><span class="n">max_index</span><span class="p">,</span> <span class="n">sub_max_index</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">FindTwoMax2</span> <span class="n">ftm2</span> <span class="p">=</span> <span class="n">new</span> <span class="n">FindTwoMax2</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">int</span><span class="p">[]</span> <span class="n">A</span> <span class="p">=</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">7</span><span class="p">}</span> <span class="p">;</span>
		<span class="n">MyResult</span> <span class="n">mr</span> <span class="p">=</span> <span class="n">ftm2</span><span class="p">.</span><span class="k">max</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">A</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="p">;</span>
		<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"max_index: "</span> <span class="p">+</span> <span class="n">mr</span><span class="p">.</span><span class="n">getMaxIndex</span><span class="p">()</span> <span class="p">+</span> <span class="s2">" sub_max_index: "</span> <span class="p">+</span> <span class="n">mr</span><span class="p">.</span><span class="n">getSubMaxIndex</span><span class="p">())</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实现三：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 用分而治之的思想解决寻找序列当中的两个最大的数
 * 列出基本的递归基情况
 * 递归调用方法
 */
public  class FindTwoMax3{
	MyResult findTwoMax3(int[] A, int lo, int hi){
		int max_index ;
		int  sub_max_index ;

		if(A.length &lt;= 1){
			System.exit(1) ;
		}
		if(lo+2 == hi){
			if(A[lo] &gt; A[lo+1]){
				max_index = lo ;
				sub_max_index = lo+1 ;
			}else{
				max_index = lo+1 ;
				sub_max_index = lo ;
			}
			return new MyResult(max_index, sub_max_index) ;
		}
		if(lo+3 == hi){
			int max = A[lo] ;
			max_index = lo ;
			if(A[lo+1] &gt; max){
				max = A[lo+1] ;
				max_index = lo+1 ;
			}
			if(A[lo+2] &gt; max){
				max = A[lo+2] ;
				max_index = lo+2 ;
			}

			if(lo != max_index){
				int sub = A[lo] ;
				sub_max_index = lo ;
				if(lo+1 == max_index){
					if(A[lo+2] &gt; sub){
						sub_max_index = lo+2 ;
					}
				}else{
					if(A[lo+1] &gt; sub){
						sub_max_index = lo+1 ;
					}
				}
			}else{
				if(A[lo+1] &gt; A[lo+2]){
					sub_max_index = lo+1 ;
				}else{
					sub_max_index = lo+2 ;
				}
			}
			return new MyResult(max_index, sub_max_index) ;
		}

		int mi = (lo+hi)/2 ;
		MyResult mrl = findTwoMax3(A, lo, mi) ;
		MyResult mrr = findTwoMax3(A, mi, hi) ;

		if(A[mrl.getMaxIndex()] &gt; A[mrr.getMaxIndex()]){
			max_index = mrl.getMaxIndex() ;
			sub_max_index = (A[mrl.getSubMaxIndex()] &gt; A[mrr.getMaxIndex()]) ? mrl.getSubMaxIndex() : mrr.getMaxIndex() ;
		}else{
			max_index = mrr.getMaxIndex() ;
			sub_max_index = (A[mrr.getSubMaxIndex()] &gt; A[mrl.getMaxIndex()]) ? mrr.getSubMaxIndex() : mrl.getMaxIndex() ;
		}
		return new MyResult(max_index, sub_max_index) ;
	}

	public static void main(String args[]){
		int[] A = {5, 9, 6, 6, 7, 2, 13} ;
		FindTwoMax3 ftm3 = new FindTwoMax3() ;
		MyResult mr = ftm3.findTwoMax3(A, 0, A.length) ;
		System.out.println("Max index --&gt; " + mr.getMaxIndex() + "\t Sub max index --&gt; " + mr.getSubMaxIndex()) ;
	}
}
</code></pre></div></div>

<blockquote>
  <p>解决算法的问题的时候，一定要在头脑里形成一个清晰的逻辑图，这样再上手写代码，不然事倍功半。</p>
</blockquote>

<blockquote>
  <p>减而治之和分而治之是解决一些算法问题的重要思想，当问题复杂的时候，要考虑到这种思想。</p>
</blockquote>

<p><strong>递归消除：尾递归</strong></p>

<p>递归算法易于理解和实现，但是在空间(甚至时间)效率低，在讲求效率时，应该将递归改写成等价的迭代形式</p>

<p>尾递归：最后一步是递归调用最简单的递归模式</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 第一个方法是尾递归的形式，时间的复杂度为O(n)+O(n) 
 * 第二个方法是迭代的形式，时间的复杂度为O(n)+O(1)
 * 在讲求效率的时候，应该将递归的形式改写为迭代的形式
 */
public class Factorial{
	static long factorial(int n){ //递归
		if(n &lt; 0){
			System.exit(1) ;
		}
		if(n == 0){
			return 1 ;
		}else{
			return n*factorial(n-1) ;
		}
	}

	static long factorial2(int n){ //迭代
		if(n &lt; 0){
			System.exit(1) ;
		}
		if(n == 0){
			return 1 ;
		}

		long fac = 1 ;
		while(n &gt; 1){
			fac *= n-- ;
		}
		return fac ;
	}

	public static void main(String args[]){
		long fac = factorial(65) ;
		System.out.println(fac) ;
	}
}
</code></pre></div></div>

<h3 id="动态规划">动态规划</h3>

<blockquote>
  <p>Make it work, Make it right, Make it fast.</p>
</blockquote>

<p><strong>斐波那契数列</strong></p>

<p>递归算法一：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 当n=39左右的时候，算法的时间就接近1秒
 * 算法的时间复杂度是O(2^n)
 */
public class Fibonacci{
	private int n ;
	public Fibonacci(int n){
		this.n = n ;
	}
	int fib(int x){
		if(x &lt; 2){
			return 1 ;
		}
		return fib(x-1) + fib(x-2) ;
	}

	public void printSquence(){
		for(int i=0; i&lt;n; i++){
			System.out.print(fib(i) + " ") ;
		}
	}

	public static void main(String args[]){
		Fibonacci f = new Fibonacci(39) ;
		f.printSquence() ;
	}
}/* output:
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 [Finished in 1.0s]
*/
</code></pre></div></div>

<p>动态规划迭代算法二：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 此算法采用动态规划，自下而上的进行迭代求解
 * 此算法的时间复杂度是O(n)
 */
public class Fibonacci2{
	private int n ;
	public Fibonacci2(int n){
		this.n = n ;
	}
	long fib(int x){
		long f = 0 ;
		long g = 1 ;		
		while(0 &lt; x--){
			g = g+f ;
			f = g-f ;
		}
		return g ;
	}

	public void printSquence(){
		for(int i=0; i&lt;n; i++){
			System.out.print(fib(i) + " ") ;
		}
	}

	public static void main(String args[]){
		Fibonacci2 f = new Fibonacci2(65) ;
		f.printSquence() ;
	}
}/* output:
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074 32951280099 53316291173 86267571272 139583862445 225851433717 365435296162 591286729879 956722026041 1548008755920 2504730781961 4052739537881 6557470319842 10610209857723 17167680177565 [Finished in 0.6s]
*/
</code></pre></div></div>

<p><strong>《Introduction to algorithm》书中的钢条切割动态规划</strong></p>

<p>递归算法求解：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 将钢条从左边切割下长度为i的一段，只对右边的n-i的一段继续进行切割(递归求解)，对左边的一段不再进行切割
 * 由于产生了大量的重复递归计算，计算的时间复杂度为O(2^n) 
 */
public class CutRod{

	public static int cutRod(int[] p, int n){
		if(n == 0){
			return 0 ;
		}

		int q = Integer.MIN_VALUE ;

		for(int i=0; i&lt;n; i++){
			q = Math.max(q, p[i]+cutRod(p, n-i-1)) ;
		}
		return q ;
	}

	public static void main(String args[]){
		int[] p = {1, 5, 8, 9, 10, 17, 17, 20, 24, 30, 32, 33, 36, 40, 42, 44, 47, 49, 52, 55, 56, 58, 60, 62, 68, 70, 75, 77, 80} ;
		int q = cutRod(p, p.length) ;
		System.out.println(p.length) ;
		System.out.println(q) ;
	}
}/* output:
29
85
[Finished in 2.5s]
*/
</code></pre></div></div>

<p>动态规划算法求解一：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 采用自上而下的递归算法
 * 保存递归过程中的子最优解，避免重复计算
 * 时间复杂度大大减小，达到了多项式时间复杂度 
 */
public class MemorizedCutRod{

	public static int memorizedCutRod(int[] p, int n){
		int[] r = new int[n] ;
		for(int i=0; i&lt;n; i++){
			r[i] = Integer.MIN_VALUE ;
		}
		return memorizedCutRodAux(p, n, r) ;
	}

	public static int memorizedCutRodAux(int[] p, int n, int[] r){
		
		if(n == 0){
			return 0 ;
		}

		if(r[n-1] &gt;= 0){
			return r[n-1] ;
		}

		int q = Integer.MIN_VALUE ;

		for(int i=0; i&lt;n; i++){
			q = Math.max(q, p[i]+memorizedCutRodAux(p, n-i-1, r)) ;
		}

		r[n-1] = q ;

		return q ;
	}

	public static void main(String args[]){
		int[] p = {1, 5, 8, 9, 10, 17, 17, 20, 24, 30, 32, 33, 36, 40, 42, 44, 47, 49, 52, 55, 56, 58, 60, 62, 68, 70, 75, 77, 80} ;
		int q = memorizedCutRod(p, p.length) ;
		System.out.println(p.length) ;
		System.out.println(q) ;
	}
}/* output:
29
85
[Finished in 0.6s]
*/
</code></pre></div></div>

<p>动态规划求解算法二：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 采用自下而上的动态规划算法
 * 先求解规模小的，利用求得并保存的结果求解规模大的
 */
public class BottomUpCutRod{
	public static int bottomUpCutRod(int[] p, int n){
		int[] r = new int[n+1] ;
		r[0] = 0 ;

		for(int j=1; j&lt;=n; j++){
			int q = Integer.MIN_VALUE ;

			for(int i=1; i&lt;=j; i++){
				q = Math.max(q, p[i-1]+r[j-i]) ;
			}
			r[j] = q ;
		}

		return r[n] ;
	}

	public static void main(String args[]){
		int[] p = {1, 5, 8, 9, 10, 17, 17, 20, 24, 30, 32, 33, 36, 40, 42, 44, 47, 49, 52, 55, 56, 58, 60, 62, 68, 70, 75, 77, 80} ;
		int q = bottomUpCutRod(p, p.length) ;
		System.out.println(p.length) ;
		System.out.println(q) ;
	}
}/* output:
29
85
[Finished in 0.6s]
*/
</code></pre></div></div>

<p>扩展算法-将最优解表示出来：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 用r数组保存每一个长度(1-n)最优结果的值
 * 用s数组保存每一个长度下最优结果的第一段切割长度
 * 通过动态规划子结构最优，能找出切割方案(方法：printCutRodSolution()实现) 
 */
class CutRodResult{
	private int[] r ;
	private int[] s ;

	public CutRodResult(int[] r, int[] s){
		this.r = r ;
		this.s = s ;
	}

	public int[] getR(){
		return r ;
	}
	public int[] getS(){
		return s ;
	}
}

public class ExtendedBottomUpCutRod{

	public static CutRodResult extendedBottomUpCutRod(int[] p, int n){
		int[] r = new int[n+1] ;
		int[] s = new int[n+1] ;
		r[0] = 0 ;

		for(int j=1; j&lt;=n; j++){
			int q = Integer.MIN_VALUE ;
			for(int i=1; i&lt;=j; i++){
				if(q &lt; p[i-1]+r[j-i]){
					q = p[i-1]+r[j-i] ;
					s[j] = i ;
					r[j] = q ;
				}
			}
		}

		return new CutRodResult(r, s) ;
	}

	public static void printCutRodSolution(int[] s, int n){
		while(n &gt; 0){
			System.out.print(s[n]+"\t") ;
			n = n-s[n] ;
		}
	}

	public static void main(String args[]){
		int[] p = {1, 5, 8, 9, 10, 17, 17, 20, 24, 30, 32, 33, 36, 40, 42, 44, 47, 49, 52, 55, 56, 58, 60, 62, 68, 70, 75, 77, 80} ;
		CutRodResult crr = extendedBottomUpCutRod(p, p.length) ;
		int[] r = crr.getR() ;
		int[] s = crr.getS() ;
		for(int ri : r){
			System.out.print(ri + "\t") ;
		}
		System.out.println() ;
		for(int si : s){
			System.out.print(si + "\t") ;
		}
		System.out.println() ;
		printCutRodSolution(s, p.length) ;
	}

}/* output:
0	1	5	8	10	13	17	18	22	25	30	32	35	38	40	43	47	49	52	55	60	62	65	68	70	73	77	79	82	85	
0	1	2	3	2	2	6	1	2	3	10	11	2	3	2	2	6	6	2	3	10	10	2	3	2	2	6	6	2	3	
3	6	10	10	[Finished in 0.7s]
*/
</code></pre></div></div>

<p><strong>动态规划求解最长公共子序列</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 在两个序列中找出最大的公共子序列
 * lcs()递归方法只能找出公共子序列的长度，而不能找出相应公共子序列的内容
 * 动态规划填表法可以找出公共子序列的大小和具体内容
 * 自下而上的动态规划求出所有子问题的最优解
 * 通过递归的方法打印出最优解
 * 递归打印妙不可言
 */
public class LongestCommonSequence{

	public static int lcs(String[] A, int a, String[]B, int b){
		if(a == 0 || b == 0){
			return 0 ;
		}

		if(A[a-1].equalsIgnoreCase(B[b-1])){
			return lcs(A, a-1, B, b-1)+1 ;
		}else{
			return lcs(A, a-1, B, b) &gt; lcs(A, a, B, b-1) ? lcs(A, a-1, B, b) : lcs(A, a, B, b-1) ;
		}
	}

	public static int[][] lcsDp(String[] A, String[] B){
		int a = A.length ;
		int b = B.length ;
		int[][] c = new int[a+1][b+1] ;
		for(int i=0,j=0; i&lt;c.length&amp;&amp;j&lt;c[0].length; i++,j++){
			c[i][0] = 0 ;
			c[0][j] = 0 ;
		}
		for(int i=1; i&lt;c.length; i++){
			for(int j=1; j&lt;c[0].length; j++){
				if(A[i-1].equalsIgnoreCase(B[j-1])){
					c[i][j] = c[i-1][j-1] + 1 ;
				}else if(c[i][j-1] &gt;= c[i-1][j]){
						c[i][j] = c[i][j-1] ;
				}else{
					c[i][j] = c[i-1][j] ;
				}
			}
		}

		for(int i=0; i&lt;a+1; i++){
			for(int j=0; j&lt;b+1; j++){
				System.out.print(c[i][j] + "\t") ;
			}
			System.out.println() ;
		}
		return c ;
	}

	public static void print(int[][] arr, String[] A, String[] B, int a, int b){
		if(a==0 || b==0){
			return ;
		}
		if(A[a-1].equalsIgnoreCase(B[b-1])){
			System.out.print(A[a-1] + "\t") ;
			print(arr, A, B, a-1, b-1) ;
		}else if(arr[a-1][b] &gt; arr[a][b-1]){
			print(arr, A, B, a-1, b) ;
		}else{
			print(arr, A, B, a, b-1) ;
		}
	}

	public static void main(String arggs[]){
		String[] A = {"e", "d", "u", "c", "a", "t", "i", "o", "n", "a", "l"} ;
		//String[] A = {"a", "d", "v", "a", "n", "t", "a", "g", "e"} ;
		//String[] A = {"d", "i", "d", "a", "c", "t", "i", "c", "a", "l"} ;
		String[] B = {"a", "d", "v", "a", "n", "t", "a", "g", "e"} ;

		int l = lcs(A, A.length, B, B.length) ;
		System.out.println(l) ;

		int[][] arr = lcsDp(A, B) ;

		print(arr, A, B, A.length, B.length) ;
	}
}/* output:
4
0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	1	
0	0	1	1	1	1	1	1	1	1	
0	0	1	1	1	1	1	1	1	1	
0	0	1	1	1	1	1	1	1	1	
0	1	1	1	2	2	2	2	2	2	
0	1	1	1	2	2	3	3	3	3	
0	1	1	1	2	2	3	3	3	3	
0	1	1	1	2	2	3	3	3	3	
0	1	1	1	2	3	3	3	3	3	
0	1	1	1	2	3	3	4	4	4	
0	1	1	1	2	3	3	4	4	4	
a	n	a	d	[Finished in 0.7s]
*/
</code></pre></div></div>

<p><strong>动态规划求解排列排序问题</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 运筹学中经典的排列排序问题
 * n件物品在m个机器上进行生产
 * n件物品的生产工序相同(工序在机器上的流向相同)
 * n件物品在同所有机器的生产顺序相同 
 * t_{ij}表示在第i个machine上加工第j个物品需要的加工时间
 * c_{ij}表示在第i个machine上加工完成第j个产品在的时刻(假设从时刻0开始生产)
 * 动态规划方法进行求解
 * 此处求解的是给定的各个物品顺序下最小的加工周期    
 * 如果要求出最优的物品加工顺序，需要用分支定界法，是多项式时间不可解的问题
 * 学术界提出了很启发式的算法(近似算法)
 */
public class PermutationSequencing{

	public static int permutationSequencing(int[][] t){
		int m = t.length ;
		int n = t[0].length ;
		int[][] c = new int[m][n] ;
		c[0][0] = t[0][0] ;

		for(int i=1; i&lt;m; i++){
			c[i][0] = c[i-1][0] + t[i][0] ;

			for(int j=1; j&lt;n; j++){
				c[0][j] =c[0][j-1] + t[0][j] ; 

				c[i][j] = Math.max(c[i-1][j], c[i][j-1])+t[i][j] ;
			}
		}
		return c[m-1][n-1] ;
	}

	public static void main(String args[]){

		int[][] t2 = {[2, 4, 4, 2, 1, 3], [5, 4, 4, 5, 7, 6],
						[5, 5, 5, 8, 5, 7], [1, 4, 3, 2, 3, 4]} ;
		int c = permutationSequencing(t2) ;
		System.out.println(c) ;
	}
}/* output:
46
[Finished in 0.7s]
*/
</code></pre></div></div>

<hr />

<hr />

<h2 id="2">2 Array-Based</h2>

<ul>
  <li>抽象数据类型(Abstract Data Type) = 数据模型 + 定义在该数据类型上的一组操作</li>
  <li>数据结构(Data Structure) = 基于某种特定的语言，实现ADT的一整套算法</li>
</ul>

<blockquote>
  <p>抽象的数据类型，比如：vector,list,stack,queue,priorityQueue，是站在logical level上说的；数据结构，比如linked list,double linked list…，是站在implementation level上说的</p>
</blockquote>

<h3 id="2.1">2.1 向量(Vector)</h3>

<p><strong>向量ADT接口</strong></p>

<p><code class="highlighter-rouge">size()</code>：报告向量当前的规模(元素总数)</p>

<p><code class="highlighter-rouge">get(r)</code>：获取秩为r的元素</p>

<p><code class="highlighter-rouge">put(r, e)</code>：用e替换秩为r元素的数值</p>

<p><code class="highlighter-rouge">insert(r, e)</code>：e作为秩为r的元素插入，原后继依次后移</p>

<p><code class="highlighter-rouge">remove(r)</code>：删除秩为r的元素，返回该元素的原值</p>

<p><code class="highlighter-rouge">disorderd()</code>：判断所有的元素是否已经按照非降序的方式排列，如果是返回0，如果不是返回按降序排列的元素对数(2个作为一对)</p>

<p><code class="highlighter-rouge">sort()</code>：调整各个元素的位置，使之按非降序排列</p>

<p><code class="highlighter-rouge">find(e)</code>：查找目标元素e，找到返回相应的秩，找不到返回-1</p>

<p><code class="highlighter-rouge">search(e)</code>：查找e，返回不大于e且最大的元素的秩</p>

<p><code class="highlighter-rouge">deduplicate(),uniquify()</code>：删除重复元素</p>

<p><code class="highlighter-rouge">traverse()</code>：遍历向量并统一处理所有的元素</p>

<p><strong>可扩容的向量</strong></p>

<ul>
  <li>扩容时使用容量加倍策略，这样具有更优的时间复杂度</li>
</ul>

<p><strong>无序向量</strong></p>

<ul>
  <li>区间删除：<code class="highlighter-rouge">remove(Rank lo, Rank hi)</code></li>
  <li>单元素删除：<code class="highlighter-rouge">remove(r)</code>，可以视为<code class="highlighter-rouge">remove(r, r+1)</code>的一种特殊情况</li>
</ul>

<blockquote>
  <p>如果基于<code class="highlighter-rouge">remove(r)</code>的接口，反复调用来实现<code class="highlighter-rouge">remove(lo, hi)</code>的区间删除，在效率上会明显的下降</p>
</blockquote>

<blockquote>
  <ul>
    <li>有序向量：T为可判等的基本类型，或者已经重载操作符”==”或者”!=”</li>
    <li>无序向量：T为可比较的基本类型，或者已经重载操作符”&lt;”或者”&gt;”</li>
  </ul>
</blockquote>

<p><strong>有序向量：唯一化</strong></p>

<ul>
  <li>唯一化的低效算法思路：从前往后，逐一比对各对相邻元素，若雷同，删除后者；否则转至后一个元素。低效的根源在于：同一元素可作为被删除元素的后继多次移动</li>
  <li>唯一化的高效算法思路：以重复区间为单位，成批删除雷同元素。用两个指针定位重复元素的个数，定位完成后，成批删除</li>
</ul>

<p><strong>有序向量：二分查找</strong></p>

<p><code class="highlighter-rouge">search(T e, Rank lo, Rank hi)</code>，语义定义：在有序向量v[lo, hi)中，确定不大于e的最后一个元素；若e比起始元素小，返回<code class="highlighter-rouge">lo-1</code>(左侧哨兵)；若e比v[hi-1]大，则返回<code class="highlighter-rouge">hi-1</code>(末元素=右侧哨兵左邻)。这里相当于在v[lo-1]的位置安置了一个左侧哨兵<code class="highlighter-rouge">-∞</code>，而在v[hi]的位置安置了一个右侧哨兵<code class="highlighter-rouge">+∞</code></p>

<p>二分查找可以通过分而治之的思想实现。如果将分点取在区间的中间((lo+hi)/2的向下取整)，则称之为Binary查找：<code class="highlighter-rouge">binsearch(T e, Rank lo, Rank hi)</code>；如果将分点取在黄金分割的位置，也就是利用斐波那契序列确定分点，则称之为Fibonacci查找：<code class="highlighter-rouge">fibsearch(T e, Rank lo, Rank hi)</code>。斐波那契查找比Binary查找具有更加高效的复杂度。</p>

<p><strong>vector的应用</strong></p>

<p>作为更加复杂的ADT的基础</p>

<p><strong>Vector VS Array</strong></p>

<ul>
  <li>Difference between a Vector and an Array?
    <ul>
      <li>A vector is a dynamic array, whose size can be increased, where as an array size can not be changed</li>
      <li>Reserve space can be given for vector, where as for array can not</li>
      <li>A vector is a class as an array in not</li>
      <li>Vector can store any type of objects, where as an array can store only homogeneous values</li>
    </ul>
  </li>
  <li>Advantages of Arrays
    <ul>
      <li>Arrays support efficient random access for the members</li>
      <li>It is easy to sort an array</li>
      <li>They are more appropriate for storing fixed number of elements</li>
    </ul>
  </li>
  <li>Disadvantages of Arrays
    <ul>
      <li>Elements can not be deleted</li>
      <li>Dynamic creation of Array is not possible</li>
      <li>Multiple data types can not be stored</li>
    </ul>
  </li>
  <li>Advantage of Vector
    <ul>
      <li>Size of the vector can be changed</li>
      <li>Multiple objects can be stored</li>
      <li>Elements can be deleted from a Vector</li>
    </ul>
  </li>
  <li>Disadvantage of Vector
    <ul>
      <li>A vector is an object, memory consumption is more</li>
    </ul>
  </li>
</ul>

<p><strong>冒泡排序算法再改进</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 此冒泡排序算法是在原来冒泡排序算法的进一步改进
 * 基本思想是：已经排好的序列我们就不再进行元素间的计较了
 */
import java.util.* ;

public class BubbleSortImpro{
	static void bubbleSortImpro(int[] A, int lo, int hi){
		boolean sorted = false ;
		while(sorted = !sorted){
			for(int i=0; i&lt;hi-1; i++){
				if(A[i] &gt; A[i+1]){
					int temp = A[i] ;
					A[i] = A[i+1] ;
					A[i+1] = temp ;
					sorted = false ;
				}
			}
			hi -- ;
		}
	}

	public static void main(String args[]){
		int[] A = new int[10] ; 
		Random rand = new Random(26) ;
		for(int i=0; i&lt;A.length; i++){
			A[i] = rand.nextInt(10) ;
		}
		//int[] A = {2, 8, 7, 6} ;
		bubbleSortImpro(A, 0, A.length) ;

		for(int a : A){
			System.out.print(a + "\t") ;
		}
	}
}/* output
2	3	3	4	4	4	7	7	7	9	[Finished in 0.6s]
*/
</code></pre></div></div>

<blockquote>
  <p>冒泡排序算法虽然可以做一些改进，但是最坏情况的时间复杂度仍然是O(n^2)</p>
</blockquote>

<p><strong>归并排序算法</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 利用分而治之的思想进行递归排序
 * 算法的时间复杂度是O(n*logn)
 * 有返回值和无返回值是等价的，有返回值只不过是把计算的结果返回罢了 
 * 有些时候“哨兵元素”在算法中相当重要，引入这样的元素能够让算法的设计更加简单
 */
import java.util.* ;
public class MergeSort{
	static void mergeSort(int[] A, int lo, int hi){
		if(lo+1 == hi){
			return ;
		}

		if(lo+1 &lt; hi){
			int mid = (lo+hi)/2 ;

			mergeSort(A, lo, mid) ;
			mergeSort(A, mid, hi) ;

			merge(A, lo, mid, hi) ;
		}
	}

	private static void merge(int[] A, int lo, int mid, int hi){
		int[] A_left = new int[mid-lo+1] ;
		int[] A_right = new int[hi-mid+1] ;

		for(int i=0; i&lt;A_left.length-1; i++){
			A_left[i] = A[lo+i] ;
		}
		for(int j=0; j&lt;A_right.length-1; j++){
			A_right[j] = A[mid+j] ;
		}

		A_left[A_left.length-1] = Integer.MAX_VALUE ; //哨兵元素
		A_right[A_right.length-1] = Integer.MAX_VALUE ; // 哨兵元素

		int i = 0 ;
		int j = 0 ;
		for(int k=lo; k&lt;hi; k++){
			if(A_left[i] &lt; A_right[j]){
				A[k] = A_left[i] ;
				i++ ;
			}else{
				A[k] = A_right[j] ;
				j++ ;
			}
		}
	}

	public static void main(String args[]){
		///*
		int[] A = new int[100000] ; 
		Random rand = new Random(26) ;
		for(int i=0; i&lt;A.length; i++){
			A[i] = rand.nextInt(10) ;
		}
		//*/
		//int[] A = {2, 4, 6, 1, 7, 8, 9} ;
		for(int i : A){
			System.out.print(i + "\t") ;
		}
		System.out.println() ;
		//int[] A = {3, 2} ;
		mergeSort(A, 0, A.length) ;
		//merge(A, 0, A.length/2, A.length) ;
		for(int i : A){
			System.out.print(i + "\t") ;
		}
	}
}/* output:
4	4	9	3	2	7	7	7	3	4	
2	3	3	4	4	4	7	7	7	9	[Finished in 0.6s]
*/
</code></pre></div></div>

<p>有返回值的MergeSort算法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">algorithm</span> <span class="p">;</span>

<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.*</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">MergeSort</span><span class="p">{</span>
	<span class="n">private</span> <span class="n">static</span> <span class="n">void</span> <span class="n">merge</span><span class="p">(</span><span class="k">Integer</span><span class="p">[]</span> <span class="k">array</span> <span class="p">,</span><span class="n">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">int</span> <span class="n">middle</span><span class="p">,</span> <span class="n">int</span> <span class="k">end</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">n1</span> <span class="p">=</span> <span class="n">middle</span> <span class="p">-</span> <span class="n">start</span> <span class="p">+</span> <span class="m">1</span> <span class="p">;</span>
		<span class="n">int</span> <span class="n">n2</span> <span class="p">=</span> <span class="k">end</span> <span class="p">-</span> <span class="n">middle</span> <span class="p">;</span>
		<span class="k">Integer</span><span class="p">[]</span> <span class="n">left</span> <span class="p">=</span> <span class="n">new</span> <span class="k">Integer</span><span class="p">[</span><span class="n">n1</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">;</span>
		<span class="k">Integer</span><span class="p">[]</span> <span class="n">right</span> <span class="p">=</span> <span class="n">new</span> <span class="k">Integer</span><span class="p">[</span><span class="n">n2</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="p">&lt;</span><span class="n">n1</span><span class="p">;</span><span class="n">i</span><span class="p">++){</span>
			<span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="k">array</span><span class="p">[</span><span class="n">start</span> <span class="p">+</span> <span class="n">i</span><span class="p">]</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="n">j</span><span class="p">&lt;</span><span class="n">n2</span><span class="p">;</span><span class="n">j</span><span class="p">++){</span>
			<span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="k">array</span><span class="p">[</span><span class="n">middle</span> <span class="p">+</span> <span class="n">j</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">left</span><span class="p">[</span><span class="n">n1</span><span class="p">]</span> <span class="p">=</span> <span class="k">Integer</span><span class="p">.</span><span class="n">MAX_VALUE</span> <span class="p">;</span>
		<span class="n">right</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="p">=</span> <span class="k">Integer</span><span class="p">.</span><span class="n">MAX_VALUE</span> <span class="p">;</span>
		<span class="n">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span> <span class="p">;</span>
		<span class="n">int</span> <span class="n">j</span> <span class="p">=</span> <span class="m">0</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">k</span><span class="p">=</span><span class="n">start</span><span class="p">;</span><span class="n">k</span><span class="p">&lt;=</span><span class="k">end</span><span class="p">;</span><span class="n">k</span><span class="p">++){</span>
			<span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&lt;</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
				<span class="k">array</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">=</span> <span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
				<span class="n">i</span><span class="p">++</span> <span class="p">;</span>
			<span class="p">}</span><span class="k">else</span><span class="p">{</span>
				<span class="k">array</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">=</span> <span class="n">right</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span>
				<span class="n">j</span><span class="p">++</span> <span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">public</span> <span class="n">static</span> <span class="k">Integer</span><span class="p">[]</span> <span class="n">mergeSort</span><span class="p">(</span><span class="k">Integer</span><span class="p">[]</span> <span class="k">array</span><span class="p">,</span> <span class="n">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">int</span> <span class="k">end</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="p">&lt;</span> <span class="k">end</span><span class="p">){</span>
			<span class="n">int</span> <span class="n">middle</span> <span class="p">=</span> <span class="p">(</span><span class="n">start</span> <span class="p">+</span> <span class="k">end</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span> <span class="p">;</span>
			<span class="n">mergeSort</span><span class="p">(</span><span class="k">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">mergeSort</span><span class="p">(</span><span class="k">array</span><span class="p">,</span> <span class="n">middle</span><span class="p">+</span><span class="m">1</span><span class="p">,</span> <span class="k">end</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">merge</span><span class="p">(</span><span class="k">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">middle</span><span class="p">,</span> <span class="k">end</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">return</span> <span class="k">array</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">Random</span> <span class="nb">random</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Random</span><span class="p">(</span><span class="m">25</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">Integer</span><span class="p">[]</span> <span class="k">array</span> <span class="p">=</span> <span class="n">new</span> <span class="k">Integer</span><span class="p">[</span><span class="m">1000000</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="p">&lt;</span><span class="k">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="p">++){</span>
			<span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">random</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">long</span> <span class="n">startTime</span> <span class="p">=</span> <span class="nf">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span> <span class="p">;</span>
		<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">Arrays</span><span class="p">.</span><span class="n">asList</span><span class="p">(</span><span class="n">mergeSort</span><span class="p">(</span><span class="k">array</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="k">array</span><span class="p">.</span><span class="n">length</span><span class="p">-</span><span class="m">1</span><span class="p">)))</span> <span class="p">;</span>
		<span class="n">long</span> <span class="n">endTime</span> <span class="p">=</span> <span class="nf">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span> <span class="p">;</span>
		<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">endTime</span> <span class="p">-</span> <span class="n">startTime</span><span class="p">)</span> <span class="p">;</span>

	<span class="p">}</span>
<span class="p">}/**</span>
   <span class="p">*</span><span class="err">对于插入排序算法，排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">33</span><span class="err">毫秒；排序</span><span class="m">100</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">4098</span><span class="err">毫秒</span>
   <span class="p">*</span><span class="err">对于</span><span class="n">Arrays</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span><span class="err">算法，排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">21</span><span class="err">毫秒；排序</span><span class="m">100</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">60</span><span class="err">毫秒；排序</span><span class="m">1</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">504</span><span class="err">毫秒；排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">2331</span><span class="err">毫秒</span>
   <span class="p">*</span><span class="err">对于分治排序算法，排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">26</span><span class="err">毫秒；排序</span><span class="m">100</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">46</span><span class="err">毫秒；排序</span><span class="m">1</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">311</span><span class="err">毫秒；排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">4728</span><span class="err">毫秒</span>
   <span class="p">*/</span>
</code></pre></div></div>

<p><strong>插入排序算法</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">algorithm</span> <span class="p">;</span>

<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.*</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">InsertionSort</span><span class="p">{</span>
	<span class="k">public</span> <span class="n">static</span> <span class="k">Integer</span><span class="p">[]</span> <span class="n">insertionSort</span><span class="p">(</span><span class="k">Integer</span><span class="p">[]</span> <span class="k">array</span><span class="p">){</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span><span class="p">=</span><span class="m">1</span><span class="p">;</span><span class="n">j</span><span class="p">&lt;</span><span class="k">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="p">++){</span>
			<span class="k">Integer</span> <span class="n">insertValue</span> <span class="p">=</span> <span class="k">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">j</span> <span class="p">-</span> <span class="m">1</span> <span class="p">;</span>
			<span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="p">&gt;=</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">insertValue</span><span class="p">){</span>
				<span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
				<span class="n">i</span><span class="p">--</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">insertValue</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">return</span> <span class="k">array</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">Double</span><span class="p">[]</span> <span class="n">insertionSort</span><span class="p">(</span><span class="n">Double</span><span class="p">[]</span> <span class="k">array</span><span class="p">){</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">j</span><span class="p">=</span><span class="m">1</span><span class="p">;</span><span class="n">j</span><span class="p">&lt;</span><span class="k">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">j</span><span class="p">++){</span>
			<span class="n">Double</span> <span class="n">insertValue</span> <span class="p">=</span> <span class="k">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">int</span> <span class="n">i</span> <span class="p">=</span> <span class="n">j</span> <span class="p">-</span> <span class="m">1</span> <span class="p">;</span>
			<span class="k">while</span><span class="p">(</span><span class="n">i</span> <span class="p">&gt;=</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">&gt;</span> <span class="n">insertValue</span><span class="p">){</span>
				<span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
				<span class="n">i</span><span class="p">--</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">insertValue</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">return</span> <span class="k">array</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span> <span class="n">args</span><span class="p">[]){</span>
		<span class="n">Random</span> <span class="nb">random</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Random</span><span class="p">(</span><span class="m">26</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">Integer</span><span class="p">[]</span> <span class="k">array</span> <span class="p">=</span> <span class="n">new</span> <span class="k">Integer</span><span class="p">[</span><span class="m">10000000</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span><span class="n">i</span><span class="p">&lt;</span><span class="k">array</span><span class="p">.</span><span class="n">length</span><span class="p">;</span><span class="n">i</span><span class="p">++){</span>
			<span class="k">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">random</span><span class="p">.</span><span class="n">nextInt</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">long</span> <span class="n">startTime</span> <span class="p">=</span> <span class="nf">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">insertionSort</span><span class="p">(</span><span class="k">array</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">long</span> <span class="n">endTime</span> <span class="p">=</span> <span class="nf">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span> <span class="p">;</span>
		<span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">endTime</span> <span class="p">-</span> <span class="n">startTime</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}/**</span>
   <span class="p">*</span><span class="err">对于插入排序算法，排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">33</span><span class="err">毫秒；排序</span><span class="m">100</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">4098</span><span class="err">毫秒</span>
   <span class="p">*</span><span class="err">对于</span><span class="n">Arrays</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span><span class="err">算法，排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">21</span><span class="err">毫秒；排序</span><span class="m">100</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">60</span><span class="err">毫秒；排序</span><span class="m">1</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">504</span><span class="err">毫秒；排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">2331</span><span class="err">毫秒</span>
   <span class="p">*</span><span class="err">对于分治排序算法，排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">26</span><span class="err">毫秒；排序</span><span class="m">100</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">46</span><span class="err">毫秒；排序</span><span class="m">1</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">311</span><span class="err">毫秒；排序</span><span class="m">10</span><span class="p">,</span><span class="m">000</span><span class="p">,</span><span class="m">000</span><span class="err">个数的数组需要</span><span class="m">4728</span><span class="err">毫秒</span>
   <span class="p">*/</span>
</code></pre></div></div>

<p><strong>Vector的自定义实现</strong></p>

<p>Vector ADT 的实现</p>

<p>抽象类 Vector.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="n">Vector</span> <span class="err">抽象类</span>
 <span class="p">*</span> <span class="err">其子类有两个，一个是</span><span class="n">FixedVector</span><span class="err">，另一个是</span><span class="n">DynamicVector</span>
 <span class="p">*</span> <span class="err">抽象类中有两个抽象方法，在子类中有不同的实现，故定义为抽象方法</span>
 <span class="p">*</span> <span class="err">抽象方法是：</span><span class="n">append</span><span class="p">()</span><span class="err">、</span><span class="n">insertAt</span><span class="p">()</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">abstract</span> <span class="n">class</span> <span class="n">Vector</span><span class="p">{</span>

	<span class="n">protected</span> <span class="n">Object</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">protected</span> <span class="n">static</span> <span class="n">final</span> <span class="n">int</span> <span class="n">DEFAULT_CAPACITY</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
	<span class="n">protected</span> <span class="n">int</span> <span class="n">numItems</span><span class="p">;</span>



	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Vector</span><span class="p">(){</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">[</span><span class="n">DEFAULT_CAPACITY</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">abstract</span> <span class="k">boolean</span> <span class="n">append</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">)</span> <span class="p">;</span>

	<span class="k">public</span> <span class="n">void</span> <span class="n">clear</span><span class="p">(){</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">numItems</span> <span class="p">=</span> <span class="m">0</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="k">boolean</span> <span class="n">contains</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="n">return</span> <span class="n">indexOf</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="c1">!= -1 ;
</span>	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">index</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">Object</span> <span class="n">elementAt</span><span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">index</span> <span class="p">&gt;</span> <span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span><span class="p">;</span>
		<span class="n">return</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">int</span> <span class="n">indexOf</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
			<span class="k">if</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">equals</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
				<span class="n">return</span> <span class="n">i</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">-</span><span class="m">1</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">index</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">abstract</span> <span class="k">boolean</span> <span class="n">insertAt</span><span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Object</span> <span class="n">element</span><span class="p">)</span> <span class="p">;</span>

	<span class="k">public</span> <span class="k">boolean</span> <span class="n">isEmpty</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">==</span> <span class="m">0</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="k">boolean</span> <span class="n">isFull</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">==</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="k">boolean</span> <span class="n">remove</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">indexOf</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="p">==</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span>
			<span class="n">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">removeAt</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">return</span> <span class="nb">true</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">index</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">Object</span> <span class="n">removeAt</span><span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">index</span> <span class="p">&gt;</span> <span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">Object</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">index</span> <span class="p">&lt;</span> <span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">index</span> <span class="p">++</span> <span class="p">;</span>
		<span class="n">data</span><span class="p">[--</span><span class="n">numItems</span><span class="p">]</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">temp</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">index</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="k">boolean</span> <span class="n">replace</span><span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">index</span> <span class="p">&gt;</span> <span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">)</span>
			<span class="n">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">element</span> <span class="p">;</span>
		<span class="n">return</span> <span class="nb">true</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">int</span> <span class="n">size</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>子类 FixedVector.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="n">FixedVector</span><span class="err">继承</span><span class="n">Vector</span><span class="err">抽象类</span>
 <span class="p">*</span> <span class="n">override</span><span class="err">抽象类中的两个抽象方法</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">FixedVector</span> <span class="n">extends</span> <span class="n">Vector</span> <span class="p">{</span>

	<span class="k">public</span> <span class="n">FixedVector</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="p">/**</span>
	<span class="p">-</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="k">boolean</span> <span class="n">append</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isFull</span><span class="p">())</span>
			<span class="n">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">numItems</span><span class="p">++]</span> <span class="p">=</span> <span class="n">element</span> <span class="p">;</span>
		<span class="n">return</span> <span class="nb">true</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">index</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="k">boolean</span> <span class="n">insertAt</span><span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">index</span><span class="p">&lt;</span><span class="m">0</span> <span class="p">||</span> <span class="n">index</span><span class="p">&gt;</span><span class="n">numItems</span><span class="p">-</span><span class="m">1</span> <span class="p">||</span> <span class="n">isFull</span><span class="p">())</span>
			<span class="n">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">&gt;=</span><span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="p">--)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">element</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
		<span class="n">return</span> <span class="nb">true</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>子类 DynamicVector.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="n">DynamicVector</span><span class="err">继承</span><span class="n">Vector</span><span class="err">抽象类</span>
 <span class="p">*</span> <span class="n">override</span><span class="err">抽象类中的抽象方法</span>
 <span class="p">*</span> <span class="p">/</span> 
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>


<span class="k">public</span> <span class="n">class</span> <span class="n">DynamicVector</span> <span class="n">extends</span> <span class="n">Vector</span> <span class="p">{</span>

	<span class="k">public</span> <span class="n">DynamicVector</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">initCapacity</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">DynamicVector</span><span class="p">(</span><span class="n">int</span> <span class="n">initCapacity</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">initCapacity</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">[</span><span class="n">DEFAULT_CAPACITY</span><span class="p">]</span> <span class="p">;</span>
		<span class="k">else</span>
			<span class="n">data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">[</span><span class="n">initCapacity</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="k">boolean</span> <span class="n">append</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="p">/*</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isFull</span><span class="p">()){</span>
			<span class="n">Object</span><span class="p">[]</span> <span class="n">newData</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">*</span><span class="m">2</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
				<span class="n">newData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="n">data</span> <span class="p">=</span> <span class="n">newData</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="p">*/</span>
		<span class="n">ensureCapacity</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">*</span><span class="m">2</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">numItems</span><span class="p">++]</span> <span class="p">=</span> <span class="n">element</span> <span class="p">;</span>
		<span class="n">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">minCapacity</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">void</span> <span class="n">ensureCapacity</span><span class="p">(</span><span class="n">int</span> <span class="n">minCapacity</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">minCapacity</span> <span class="p">&lt;=</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
			<span class="n">return</span> <span class="p">;</span>
		<span class="n">Object</span><span class="p">[]</span> <span class="n">newData</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">[</span><span class="n">minCapacity</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
			<span class="n">newData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">newData</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">index</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="k">boolean</span> <span class="n">insertAt</span><span class="p">(</span><span class="n">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">index</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">index</span> <span class="p">&gt;</span> <span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">)</span>
			<span class="n">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isFull</span><span class="p">()){</span>
			<span class="n">Object</span><span class="p">[]</span> <span class="n">newData</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Object</span><span class="p">[</span><span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">*</span><span class="m">2</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">,</span><span class="n">j</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;</span><span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="p">++,</span><span class="n">j</span><span class="p">++){</span>
				<span class="k">if</span><span class="p">(</span><span class="n">j</span> <span class="p">==</span> <span class="n">index</span><span class="p">)</span>
					<span class="n">i</span> <span class="p">++</span> <span class="p">;</span>
				<span class="n">newData</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="n">data</span> <span class="p">=</span> <span class="n">newData</span> <span class="p">;</span>
			<span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">element</span> <span class="p">;</span>
			<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
			<span class="n">return</span> <span class="nb">true</span> <span class="p">;</span>
		<span class="p">}</span>

		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">&gt;=</span><span class="n">index</span><span class="p">;</span> <span class="n">i</span><span class="p">--)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">element</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
		<span class="n">return</span> <span class="nb">true</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>利用定义的Vector ADT记性排序(Sort)和查找(Search)</p>

<p>查找类 Search.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">将查找定义为一个类，类中提供静态方法，传递向量和查找对象进行查找操作</span>
 <span class="p">*</span> <span class="err">一共提供两种查找方法：二分查找</span><span class="p">(</span><span class="n">binarySearch</span><span class="p">())</span><span class="err">和线性查找</span><span class="p">(</span><span class="n">linearSearch</span><span class="p">())</span>
 <span class="p">*</span> <span class="err">两种查找方法的参数</span><span class="n">Vector</span><span class="err">，都是有序</span><span class="n">Vector</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span> <span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">.</span><span class="n">Vector</span> <span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">.</span><span class="n">Comparable</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">Search</span><span class="p">{</span>

	<span class="n">private</span> <span class="n">Search</span><span class="p">(){}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">int</span> <span class="n">binSearch</span><span class="p">(</span><span class="n">Vector</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Comparable</span> <span class="n">target</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">first</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
			<span class="n">last</span> <span class="p">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
			<span class="n">middle</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">last</span> <span class="p">-</span> <span class="n">first</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">){</span>
			<span class="n">middle</span> <span class="p">=</span> <span class="p">(</span><span class="n">first</span> <span class="p">+</span> <span class="n">last</span><span class="p">)</span> <span class="p">/</span> <span class="m">2</span> <span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">middle</span><span class="p">))</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
				<span class="n">last</span> <span class="p">=</span> <span class="n">middle</span><span class="p">-</span><span class="m">1</span> <span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">middle</span><span class="p">))</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
				<span class="n">first</span> <span class="p">=</span> <span class="n">middle</span><span class="p">+</span><span class="m">1</span> <span class="p">;</span>
			<span class="k">else</span>
				<span class="n">return</span> <span class="n">middle</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">return</span> <span class="p">-</span><span class="m">1</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">int</span> <span class="n">linearSearchSort</span><span class="p">(</span><span class="n">Vector</span> <span class="n">vec</span><span class="p">,</span> <span class="n">Comparable</span> <span class="n">target</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">j</span><span class="p">,</span>
			<span class="n">n</span> <span class="p">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">j</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;</span><span class="n">n</span> <span class="p">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">j</span><span class="p">))&gt;</span><span class="m">0</span><span class="p">;</span> <span class="n">j</span><span class="p">++)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="p">&lt;</span><span class="n">n</span> <span class="p">&amp;&amp;</span> <span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">j</span><span class="p">))</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">j</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">-</span><span class="m">1</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>辅助接口 Comparable.java</p>
</blockquote>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">可比较的接口，任何实现了此接口的</span><span class="n">object</span><span class="err">，都是可比较的，要</span><span class="n">override</span> <span class="n">compareTo</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span><span class="err">方法，以此来指定比较规则</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">interface</span> <span class="n">Comparable</span><span class="p">{</span>
	<span class="n">int</span> <span class="n">compareTo</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>排序类 Sort.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">将排序定义为一个类，提供静态方法</span>
 <span class="p">*</span> <span class="err">两种排序方法</span><span class="p">:</span> <span class="err">冒泡排序</span><span class="p">(</span><span class="n">bubbleSort</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">vec</span><span class="p">))</span><span class="err">和选择排序</span><span class="p">(</span><span class="n">selectionSort</span><span class="p">(</span><span class="n">Vector</span><span class="p">,</span> <span class="n">vec</span><span class="p">))</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span> <span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">.</span><span class="n">Vector</span> <span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">.</span><span class="n">Comparable</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">Sort</span><span class="p">{</span>

	<span class="n">private</span> <span class="n">Sort</span><span class="p">()</span> <span class="p">{}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Vector</span> <span class="n">vec</span><span class="p">,</span> <span class="n">int</span> <span class="n">first</span><span class="p">,</span> <span class="n">int</span> <span class="n">second</span><span class="p">){</span>
		<span class="n">Object</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">vec</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">second</span><span class="p">))</span> <span class="p">;</span>
		<span class="n">vec</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="n">second</span><span class="p">,</span> <span class="n">temp</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">bubbleSort</span><span class="p">(</span><span class="n">Vector</span> <span class="n">vec</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">i</span><span class="p">,</span>
			<span class="n">j</span><span class="p">,</span>
			<span class="n">n</span><span class="p">=</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">Comparable</span> <span class="n">first</span> <span class="p">;</span>
		<span class="n">Comparable</span> <span class="n">second</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">i</span><span class="p">=</span><span class="n">n</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">&gt;</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">--){</span>
			<span class="n">for</span><span class="p">(</span><span class="n">j</span><span class="p">=</span><span class="m">1</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;=</span><span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="p">++){</span>
				<span class="n">first</span> <span class="p">=</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">j</span><span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">;</span>
				<span class="n">second</span> <span class="p">=</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="c1">!(first.compareTo(second)&lt;0)){
</span>					<span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">j</span><span class="p">-</span><span class="m">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>	
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">selectionSort</span><span class="p">(</span><span class="n">Vector</span> <span class="n">vec</span><span class="p">){</span>
		<span class="n">int</span> <span class="n">i</span><span class="p">,</span>
			<span class="n">j</span><span class="p">,</span>
			<span class="n">n</span> <span class="p">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> 
			<span class="n">small_pos</span> <span class="p">;</span>
		<span class="n">Comparable</span> <span class="n">smallest</span><span class="p">,</span>
				   <span class="n">current</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">n</span><span class="p">-</span><span class="m">1</span><span class="p">;</span> <span class="n">i</span><span class="p">++){</span>
			<span class="n">small_pos</span> <span class="p">=</span> <span class="n">i</span> <span class="p">;</span>
			<span class="n">smallest</span> <span class="p">=</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">small_pos</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">for</span><span class="p">(</span><span class="n">j</span><span class="p">=</span><span class="n">i</span><span class="p">+</span><span class="m">1</span><span class="p">;</span> <span class="n">j</span><span class="p">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="p">++){</span>
				<span class="n">current</span> <span class="p">=</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">smallest</span><span class="p">)</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">){</span>
					<span class="n">small_pos</span> <span class="p">=</span> <span class="n">j</span> <span class="p">;</span>
					<span class="n">smallest</span> <span class="p">=</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">vec</span><span class="p">.</span><span class="n">elementAt</span><span class="p">(</span><span class="n">small_pos</span><span class="p">)</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span><span class="p">(</span><span class="n">small_pos</span> <span class="c1">!= i)
</span>				<span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">small_pos</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />

<h3 id="2.2">2.2 堆(Heap)</h3>

<blockquote>
  <p>A binary tree is collection of elements called nodes. The collection is either empty or it consists of a node called the root, along with two binary trees called the left and right subtrees. The roots of the left and right subtrees are children of the root; the root is the parent of these children. An edge connects each node of a binary tree to each of its children. A node with no children is called leaf. A node having at least one child is called an internal node.</p>
</blockquote>

<blockquote>
  <p>The depth of node n in binary tree is the number of edges that must be traversed when travelling from the root of the tree to n. The height of the tree is one more than the depth of the depth of the deepest node. All nodes with depth d are said to be at level d of the tree.</p>
</blockquote>

<blockquote>
  <p>A binary tree is called complete if it was built by filling its levels from left to right, starting at the root.</p>
</blockquote>

<p><strong>堆的定义</strong></p>

<p>A heap is a partially ordered complete binary tree. That is to say partially ordered is to say that there is some relationship between the value of a node and the value of ots children. In a min-heap, the value of a node is less than or equal to the values of its children. In a max-heap, the value of a node is greater than or equals to the values of its children.</p>

<p><strong>heap的实现</strong></p>

<p>Heap.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="n">heap</span><span class="err">抽象类定义了两个抽象方法</span> <span class="n">percolate</span><span class="p">()</span><span class="err">、</span><span class="n">sift</span><span class="p">()</span>
 <span class="p">*</span> <span class="err">抽象方法的覆写不同会导致</span><span class="n">MinHeap</span><span class="err">和</span><span class="n">MaxHeap</span><span class="err">中的</span><span class="n">insert</span><span class="err">和</span><span class="n">remove</span><span class="err">方法有不同的实现</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">abstract</span> <span class="n">class</span> <span class="n">Heap</span><span class="p">{</span>
	<span class="n">protected</span> <span class="n">Comparable</span><span class="p">[]</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">protected</span> <span class="n">static</span> <span class="n">final</span> <span class="n">int</span> <span class="n">DEFAULT_CAPACITY</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
	<span class="n">protected</span> <span class="n">int</span> <span class="n">numItems</span><span class="p">;</span>




	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Heap</span><span class="p">(){</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Comparable</span><span class="p">[</span><span class="n">DEFAULT_CAPACITY</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">initCapacity</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">Heap</span><span class="p">(</span><span class="n">int</span> <span class="n">initCapacity</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">initCapacity</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Comparable</span><span class="p">[</span><span class="n">DEFAULT_CAPACITY</span><span class="p">]</span> <span class="p">;</span>
		<span class="k">else</span>
			<span class="n">data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Comparable</span><span class="p">[</span><span class="n">initCapacity</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="n">clear</span><span class="p">(){</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
			<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">=</span> <span class="m">0</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="n">contract</span><span class="p">(){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">numItems</span> <span class="p">==</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
			<span class="n">return</span> <span class="p">;</span>

		<span class="n">Comparable</span><span class="p">[]</span> <span class="n">new_data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Comparable</span><span class="p">[</span><span class="n">numItems</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">new_data</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
			<span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">new_data</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">Comparable</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isFull</span><span class="p">()){</span>
			<span class="n">Comparable</span><span class="p">[]</span> <span class="n">new_data</span> <span class="p">=</span> <span class="n">new</span> <span class="n">Comparable</span><span class="p">[</span><span class="n">numItems</span> <span class="p">&lt;&lt;</span> <span class="m">1</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">for</span><span class="p">(</span><span class="n">int</span> <span class="n">i</span><span class="p">=</span><span class="m">0</span><span class="p">;</span> <span class="n">i</span><span class="p">&lt;</span><span class="n">numItems</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
				<span class="n">new_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span>
			<span class="n">data</span> <span class="p">=</span> <span class="n">new_data</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">data</span><span class="p">[</span><span class="n">numItems</span><span class="p">++]</span> <span class="p">=</span> <span class="n">element</span> <span class="p">;</span>
		<span class="n">percolate</span><span class="p">()</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="k">boolean</span> <span class="n">isFull</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">==</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="k">boolean</span> <span class="n">isEmpty</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">==</span> <span class="m">0</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="k">boolean</span> <span class="n">isLeaf</span><span class="p">(</span><span class="n">int</span> <span class="n">pos</span><span class="p">){</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">pos</span> <span class="p">&lt;&lt;</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="m">1</span> <span class="p">&gt;=</span> <span class="n">numItems</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">pos</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">int</span> <span class="n">leftChild</span><span class="p">(</span><span class="n">int</span> <span class="n">pos</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">pos</span> <span class="p">&lt;&lt;</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="m">1</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">pos</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">int</span> <span class="n">parent</span><span class="p">(</span><span class="n">int</span> <span class="n">pos</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">return</span> <span class="p">-</span><span class="m">1</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">pos</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span> <span class="p">&gt;&gt;</span> <span class="m">1</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">Comparable</span> <span class="n">peek</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">abstract</span> <span class="n">void</span> <span class="n">percolate</span><span class="p">();</span>

	<span class="n">protected</span> <span class="n">Comparable</span> <span class="n">remove</span><span class="p">(){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">Comparable</span> <span class="n">root</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">numItems</span><span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">data</span><span class="p">[--</span><span class="n">numItems</span><span class="p">]</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">numItems</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">sift</span><span class="p">()</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">root</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">pos</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">int</span> <span class="n">rightChild</span><span class="p">(</span><span class="n">int</span> <span class="n">pos</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">pos</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">pos</span> <span class="p">&lt;&lt;</span> <span class="m">1</span><span class="p">)</span> <span class="p">+</span> <span class="m">2</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">abstract</span> <span class="n">void</span> <span class="n">sift</span><span class="p">();</span>

	<span class="k">public</span> <span class="n">int</span> <span class="n">size</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">arr</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">first</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">second</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Comparable</span><span class="p">[]</span> <span class="n">arr</span><span class="p">,</span> <span class="n">int</span> <span class="n">first</span><span class="p">,</span> <span class="n">int</span> <span class="n">second</span><span class="p">){</span>
		<span class="n">Comparable</span> <span class="n">tmp</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="p">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">second</span><span class="p">]</span> <span class="p">;</span>
		<span class="n">arr</span><span class="p">[</span><span class="n">second</span><span class="p">]</span> <span class="p">=</span> <span class="n">tmp</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>MinHeap.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">通过对父类中抽象方法的覆写，从而实现</span><span class="n">insert</span><span class="err">和</span><span class="n">remove</span><span class="err">方法的不同实现</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">MinHeap</span> <span class="n">extends</span> <span class="n">Heap</span> <span class="p">{</span>



	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">initCapacity</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">MinHeap</span><span class="p">(</span><span class="n">int</span> <span class="n">initCapacity</span><span class="p">){</span>
		<span class="n">super</span><span class="p">(</span><span class="n">initCapacity</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">MinHeap</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">peekMin</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">peek</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">void</span> <span class="n">percolate</span><span class="p">(){</span>
		<span class="n">int</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">size</span><span class="p">()</span> <span class="p">-</span><span class="m">1</span> <span class="p">;</span>

		<span class="k">while</span><span class="p">(</span><span class="n">pos</span> <span class="c1">!= 0 &amp;&amp;
</span>				<span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">parent</span><span class="p">(</span><span class="n">pos</span><span class="p">)])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">){</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">parent</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span> <span class="p">;</span>
			<span class="n">pos</span> <span class="p">=</span> <span class="n">parent</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">removeMin</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">remove</span><span class="p">()</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">void</span> <span class="n">sift</span><span class="p">(){</span>
		<span class="n">int</span> <span class="n">pos</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
			<span class="n">i</span> <span class="p">,</span>
			<span class="n">r_pos</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="c1">!isLeaf(pos)){
</span>			<span class="n">i</span> <span class="p">=</span> <span class="n">leftChild</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">r_pos</span> <span class="p">=</span> <span class="n">rightChild</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">r_pos</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">r_pos</span><span class="p">])</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
				<span class="n">i</span> <span class="p">=</span> <span class="n">r_pos</span> <span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span>
				<span class="n">return</span> <span class="p">;</span>

			<span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">;</span>

			<span class="n">pos</span> <span class="p">=</span> <span class="n">i</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>MaxHeap.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">MaxHeap</span> <span class="n">extends</span> <span class="n">Heap</span> <span class="p">{</span>



	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">MaxHeap</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">initCapacity</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">MaxHeap</span><span class="p">(</span><span class="n">int</span> <span class="n">initCapacity</span><span class="p">){</span>
		<span class="n">super</span><span class="p">(</span><span class="n">initCapacity</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">peekMax</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">peek</span><span class="p">()</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">void</span> <span class="n">percolate</span><span class="p">(){</span>
		<span class="n">int</span> <span class="n">pos</span> <span class="p">=</span> <span class="n">size</span><span class="p">()</span> <span class="p">-</span> <span class="m">1</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">pos</span> <span class="c1">!= 0 &amp;&amp;
</span>				<span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">parent</span><span class="p">(</span><span class="n">pos</span><span class="p">)])</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">){</span>
			<span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">parent</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span> <span class="p">;</span>
			<span class="n">pos</span> <span class="p">=</span> <span class="n">parent</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">removeMax</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">remove</span><span class="p">()</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="n">protected</span> <span class="n">void</span> <span class="n">sift</span><span class="p">(){</span>
		<span class="n">int</span> <span class="n">pos</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span>
			<span class="n">i</span><span class="p">,</span>
			<span class="n">r_pos</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="c1">!isLeaf(pos)){
</span>			<span class="n">i</span> <span class="p">=</span> <span class="n">leftChild</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">r_pos</span> <span class="p">=</span> <span class="n">rightChild</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">r_pos</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">()</span> <span class="p">&amp;&amp;</span>
					<span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">r_pos</span><span class="p">])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
				<span class="n">i</span> <span class="p">=</span> <span class="n">r_pos</span> <span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">].</span><span class="n">compareTo</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">)</span>
				<span class="n">return</span> <span class="p">;</span>

			<span class="n">swap</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">;</span>

			<span class="n">i</span> <span class="p">=</span> <span class="n">pos</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><strong>堆排序(heap sort)的实现</strong></p>

<p>HeapSort.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 将可比较的对象插入堆中
 * 从堆中不断删除root
 * 即可得到从小到大的排序
 */
import java.util.* ;

import org.fmz.container.MinHeap ;

public class HeapSort{
	public static void heapSort(int[] array){
		int n = array.length ;
		MinHeap heap = new MinHeap(n) ;

		for(int i=0; i&lt;n; i++)
			heap.insert((Comparable)array[i]) ;
		for(int j=0; j&lt;n; j++)
			array[j] = (int)heap.removeMin() ; 
	}

	public static void main(String args[]){
		int[] array = new int[10] ;
		Random rand = new Random(26) ;
		for(int i=0; i&lt;array.length; i++)
			array[i] = rand.nextInt(10) ;
		heapSort(array) ;
		for(int i : array)
			System.out.print(i + "\t") ;
	}
}/* output
2	3	3	4	4	4	7	7	7	9	[Finished in 0.6s]
*/
</code></pre></div></div>

<p><strong>Quick Sort</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * Quick sort 和 Merge sort 都是采用递归的思想解决问题，使用 Divide-and-Conquer策略
 * 将一个长的序列分解成很多年小的序列，在每个序列上递归调用，当序列足够小的时候，使用插入排序方法排序
 * 核心点在于找到一个中间数(或者是随机的一个数)，使得partition之后的两个序列，其中一个序列的数都小于等于中间数，而另一个都大于等于中间数
 */
import java.util.* ;

public class QuickSort{
	public static void swap(int[] array, int first, int second){
		int temp = array[first] ;
		array[first] = array[second] ;
		array[second] = temp ;
	}

	static void medianOf3(int[] array, int left, int right){
		int middle = (left + right) &gt;&gt; 1 ;	

		if(array[left] &gt; array[middle])
			swap(array, left, middle) ;

		if(array[middle] &gt; array[right])
			swap(array, middle, right) ;

		if(array[left] &gt; array[middle])
			swap(array, left, middle) ;
	}

	static int partition(int[] array, int left, int right){
		int middle = (left + right) &gt;&gt; 1 ;
		int pivot = array[middle] ;
		while(true){
			while(array[left++] &lt; pivot) ;
			while(array[right--] &gt; pivot) ;
			if(left &lt; right)
				swap(array, left-1, right+1) ;
			else
				return left-1 ;
				
		}
	}

	public static void insertionSort(int[] array, int left, int right){
		int start = left ;
		if(left == right)
			return ;
		while(left &lt; right){
			int insert_value = array[++left] ;
			int walker = left-1 ;
			while(walker &gt;= start &amp;&amp; array[walker] &gt; insert_value){
				array[walker+1] = array[walker] ;
				walker -- ;
			}
			array[walker+1] = insert_value ;
		}
	}

	public static void quickSort(int[] array, int left, int right){
		if(right-left + 1 &lt;= 10)
			insertionSort(array, left, right) ;
		else{
			medianOf3(array, left, right) ;
			int left_part = partition(array, left, right) ;
			quickSort(array, left, left_part-1) ;
			quickSort(array, left_part, right) ;
		}
	}

	public static void main(String args[]){
		Random rand = new Random(24) ;
		int[] array = new int[20] ;
		for(int i=0; i&lt;array.length; i++)
			array[i] = rand.nextInt(10) ;

		quickSort(array, 0, array.length-1) ;

		for(int i : array){
			System.out.print(i + "\t") ;
		}
	}
}/* output
0	0	1	2	3	0	2	4	4	4	4	4	5	6	7	7	8	8	8	9	[Finished in 0.7s]
*/
</code></pre></div></div>

<p><strong>Shell Sort</strong></p>

<p>ShellSort.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * Shell sort是Insertion sort的一个扩展
 * 使用1 4 13 40 ... 这样的序列作为interval
 * 从最大的interval开始值排序像个interval的数据
 * 不断缩小interval
 * 当interval为1时，即为插入排序，排序的速度会非常快，因为有前面许多interval为基础的序列已经排序好了
 */
import java.util.* ;

public class ShellSort{

	public static void shellSort(int[] array){
		int inner,
			outer,
			target ;
		int h = 1 ;
		while(h &lt;= array.length)
			h = h*3 + 1 ;

		while(h &gt; 0){
			for(outer = h; outer &lt; array.length; outer++){
				target = array[outer] ;
				inner = outer ;
				while(inner &gt; h-1 &amp;&amp; array[inner-h] &gt; target){
					array[inner] = array[inner-h] ;
					inner -= h ;
				}
				array[inner] = target ;
			}
			h = (h-1) / 3 ;
		}
	}

	public static void main(String args[]){
		Random rand = new Random(24) ;
		int[] array = new int[20] ;
		for(int i=0; i&lt;array.length; i++)
			array[i] = rand.nextInt(10) ;
		shellSort(array) ;

		for(int i : array){
			System.out.print(i + "\t") ;
		}
	}
}/* output
0	0	0	1	2	2	3	4	4	4	4	4	5	6	7	7	8	8	8	9	[Finished in 0.6s]
*/
</code></pre></div></div>

<hr />

<hr />

<h2 id="3">3 列表</h2>

<blockquote>
  <p>Linked list: a linear collection of nodes in which each node has, at a minimun, a data portion and a link portion; a node’s link portion is a pointer or reference to the next node in the list, unless there is no next node, in which case the link portion is empty.</p>
</blockquote>

<blockquote>
  <p>The nodes of a linked list are not stored in contiguous blocks of memory, hence the links. Only the memory address of the first and last nodes are stored outside the list; the memory address of any internal node is stored in another node, namely the predecessor. This means that a given internal node can be accessed only by navigating to that node by way of the links, starting with head. Thus a linked list is a sequential-access structure, like a audio or video cassette.</p>
</blockquote>

<h3 id="3.1">3.1 栈(Stack)</h3>

<p><strong>栈的典型应用</strong></p>

<ul>
  <li>逆序输出(conversion)，输出次序与处理的过程颠倒：递归深度和输出长度不易预知</li>
  <li>递归嵌套(stack permutation + parenthesis)：具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定、</li>
  <li>延迟缓冲(evaliation)：线性扫描算法模式中，在预读足够长之后，方能确定可处理的前缀</li>
  <li>栈式计算(RPN)：基于栈结构的特定计算模式</li>
</ul>

<p><strong>括号匹配</strong></p>

<p>BrancketsMatch.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 从开始扫描可能需要匹配的符号，这是包括：() [] {} &lt;&gt;
 * 将出现左边的符号 '( [ { &lt;' 压入栈中
 * 扫描的右边的符号且栈顶符号与之相匹配时，将栈顶弹出
 * 如果右边的符号和栈顶的符号不符合，则直接返回false，匹配失败
 */
//package test ;

import java.util.* ;

public class BracketsMatch{

	public static boolean bracketsMatch(String str){
		char[] char_ary = str.toCharArray() ;
		Stack&lt;Character&gt; sta = new Stack&lt;Character&gt;() ; 

		for(int i=0; i&lt;char_ary.length; i++){
			char c = char_ary[i] ;
			try{
				switch(c){
					case '(': sta.push('(') ;
						break ;
					case '[': sta.push('[') ;
						break ;
					case '{': sta.push('{') ;
						break ;
					case '&lt;': sta.push('&lt;') ;
						break ;
					case ')':
						if(sta.peek().equals('(')){
							sta.pop() ;
							break ;
						}else
							return false ;
					case ']':
						if(sta.peek().equals('[')){
							sta.pop() ;
							break ;
						}else
							return false ;
					case '}':
						if(sta.peek().equals('{')){
							sta.pop() ;
							break ;
						}else
							return false ;
					case '&gt;':
						if(sta.peek().equals('&lt;')){
							sta.pop() ;
							break ;
						}else
							return false ;
				}
 			}catch(EmptyStackException ese){
 				return false ;
			}
		}
		return sta.empty() ;
	}
	public static void main(String args[]){
		String str = "{()[][()][]}" ;
		//String str = "[(])" ;
		boolean result = bracketsMatch(str) ;
		System.out.println(result) ;
	}
}
</code></pre></div></div>

<p><strong>栈混洗(stack permutation)</strong></p>

<p>将栈A的元素，通过一个中转的栈S，全部转移到栈B中的过程。将A中的元素不断push到S中，S可以选择在何时pop，从而将中转元素push到B中，这样的一个过程称之为栈混洗。</p>

<blockquote>
  <p>栈混洗的方式可能有多种，但是最多也不会超过全排列的总数。
判断任意给出一个全排列，是否是输入序列的栈混洗是一个问题。</p>
</blockquote>

<blockquote>
  <p>栈混洗和括号匹配之间存在关系——n个元素的栈混洗，等价于n对括号的匹配。</p>
</blockquote>

<p><strong>中缀表达式(infix expression)计算</strong></p>

<p>InfixExpressionEvaluate.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 中缀表达式的计算用于计算有优先级的符号计算
 * 利用栈的数据结构来保存两个栈
 * 运算符栈保存运算符(+-*/^!...)，运算符栈的起始加入一个哨兵元素和表达式中人为加入的哨兵元素想对应
 * 操作数栈用于保存数据
 * 遍历的将表达式字符入栈，如果运算符有更高的优先级，继续入栈，直到有低的优先级出现，则可以计算栈中的最高优先级，也即运算符栈顶元素
 * 操作数栈的元素也随着运算符栈的元素变化而变化，变化发生在有可以计算的最高优先级，否则继续入栈
 * 最后操作数栈只剩下一个元素，也即中缀表达式的值
 */
import java.util.* ;

public class InfixExpressionEvaluate{

	public static int compare(char x, char y){
		switch(x){
			case '+':
				switch(y){
					case '+': return -1 ;
					case '-': return -1 ;
					case '*': return -1 ;
					case '/': return -1 ;
					case '^': return -1 ;
					case '!': return -1 ;
					case '(': return 1 ;
					case ')': return 2 ;
					case '$': return 1 ;
				}
			case '-':
				switch(y){
					case '+': return -1 ;
					case '-': return -1 ;
					case '*': return -1 ;
					case '/': return -1 ;
					case '^': return -1 ;
					case '!': return -1 ;
					case '(': return 1 ;
					case ')': return 2 ;
					case '$': return 1 ;
				}
			case '*':
				switch(y){
					case '+': return 1 ;
					case '-': return 1 ;
					case '*': return -1 ;
					case '/': return -1 ;
					case '^': return -1 ;
					case '!': return -1 ;
					case '(': return 1 ;
					case ')': return 2 ;
					case '$': return 1 ;
				}
			case '/':
				switch(y){
					case '+': return 1 ;
					case '-': return 1 ;
					case '*': return -1 ;
					case '/': return -1 ;
					case '^': return -1 ;
					case '!': return -1 ;
					case '(': return 1 ;
					case ')': return 2 ;
					case '$': return 1 ;
				}
			case '^':
				switch(y){
					case '+': return 1 ;
					case '-': return 1 ;
					case '*': return 1 ;
					case '/': return 1 ;
					case '^': return -1 ;
					case '!': return -1 ;
					case '(': return 1 ;
					case ')': return 2 ;
					case '$': return 1 ;
				}
			case '!':
				switch(y){
					case '+': return 1 ;
					case '-': return 1 ;
					case '*': return 1 ;
					case '/': return 1 ;
					case '^': return 1 ;
					case '!': return -1 ;
					case '(': return 1 ;
					case ')': return 2 ;
					case '$': return 1 ;
				}
			case '(':
				switch(y){
					case '+': return 1 ;
					case '-': return 1 ;
					case '*': return 1 ;
					case '/': return 1 ;
					case '^': return 1 ;
					case '!': return 2 ;
					case '(': return 1 ;
					case ')': return 2 ;
					case '$': return 1 ;
				}
			case ')':
				switch(y){
					case '+': return -1 ;
					case '-': return -1 ;
					case '*': return -1 ;
					case '/': return -1 ;
					case '^': return -1 ;
					case '!': return -1 ;
					case '(': return 0 ;
					case ')': return 2 ;
					case '$': return 2 ;
				}
			case '$':
				switch(y){
					case '+': return -1 ;
					case '-': return -1 ;
					case '*': return -1 ;
					case '/': return -1 ;
					case '^': return -1 ;
					case '!': return -1 ;
					case '(': return 2 ;
					case ')': return 2 ;
					case '$': return 0 ;
				}
		}
		return 3 ;
	}

	public static int factorial(int n){
		if(n &lt; 0){
			System.exit(1) ;
		}
		if(n == 0){
			return 1 ;
		}

		int fac = 1 ;
		while(n &gt; 1){
			fac *= n-- ;
		}
		return fac ;
	}

	public static int operate(char x, int first, int folloing){
		switch(x){
			case '+': return folloing + first ;
			case '-': return folloing - first ;
			case '*': return folloing * first ;
			case '/': return folloing / first ;
			case '^':
				int exponential = 1 ; 
				while(first &gt; 0){
					exponential *= folloing ;
					first -- ;
				}
				return exponential ;
		}
		return -1 ;
	}

	public static int evaluate(char[] infix_expr){
		Stack&lt;Character&gt; operator_stack = new Stack&lt;Character&gt;() ;
		Stack&lt;Integer&gt; digital_stack = new Stack&lt;Integer&gt;() ;
		operator_stack.push('$') ;
		while(!operator_stack.empty()){
			for(int i=0; i&lt;infix_expr.length; i++){
				if(Character.isDigit(infix_expr[i])){
					int read_number = Character.getNumericValue(infix_expr[i]) ;
					int j = i ;
					while(Character.isDigit(infix_expr[++j])){
						read_number = read_number*10 + Character.getNumericValue(infix_expr[j]) ;
					}
					i = j - 1 ;
					digital_stack.push(read_number) ;
				}else{
					if(compare(infix_expr[i], operator_stack.peek()) == 1)
						operator_stack.push(infix_expr[i]) ;
					else if(compare(infix_expr[i], operator_stack.peek()) == 0)
						operator_stack.pop() ;
					else if(compare(infix_expr[i], operator_stack.peek()) == -1){
						if(operator_stack.peek().equals('!')){
							operator_stack.pop() ;
							int digital_cal = digital_stack.pop() ;
							digital_stack.push(factorial(digital_cal)) ;
							
						}
						else{
							char operate_cal = operator_stack.pop() ;
							int digital_first = digital_stack.pop() ;
							int digital_following = digital_stack.pop() ;							
							digital_stack.push(operate(operate_cal, digital_first, digital_following)) ;
						}
						i -- ;
					}
					else{
						System.err.println("Something error.") ;
						return -1 ;
					}
						
				}
			}
		}
		return digital_stack.pop() ;
	}

	public static void main(String args[]){
		String infix_expression = "(1+2^3!-4)*(5!-(6-(7-(89-0!))))" ;
		int result = evaluate(infix_expression.concat("$").toCharArray()) ;
		System.out.println(result) ;
	}
}/*output
2013
[Finished in 0.7s]
*/
</code></pre></div></div>

<p><strong>利用逆波兰表达式(Reverse Polish Notation)进行中缀表达式的计算</strong></p>

<blockquote>
  <p>我们可以将中缀表达式表示成逆波兰表达式的形式，也称之为后缀表达式</p>
</blockquote>

<p>将中缀表达式转化为后缀表达式的算法：</p>

<ul>
  <li>Create an empt stack called opstack for keeping operators. Create an empty list for output.</li>
  <li>Convert the input infix string to a list by using string method split.</li>
  <li>Scan the token list from left to right.
    <ul>
      <li>if the token is an operand, append it to the end of the output list.</li>
      <li>if the token is a left paranthesis, push it on the optstack.</li>
      <li>if the token is the right paranthesis, pop the opstack until the corresponding left parenthesis is removed. Append each operator to the end of the output list.</li>
      <li>if the token is an operator(+-^…), push it to the opstack. However, first remove any operator already on the opstack that have higher or equal precedence and append them to the output list.</li>
    </ul>
  </li>
  <li>When the input expression has been completely processed, check the opstack. Any operators still on the stack can be removed and appended to the end of the output list.</li>
</ul>

<p>算法实现：ReversePolishNotation.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * 中缀表达式转化为后缀表达式时候要保存在一个字符串序列当中，将大于9的数转化为字符串，保存在字符序列中不可行
 * 后缀表达式的计算简单，只需要保存一个整数栈即可
 */
import java.util.* ;

public class ReversePolishNotation{

	public static List&lt;String&gt; infixToPostfix(char[] infix_expr){
		Stack&lt;Character&gt; operator_stack = new Stack&lt;Character&gt;() ;
		List&lt;String&gt; postfix = new ArrayList&lt;String&gt;() ;
		operator_stack.push('(') ;

		for(int i=0; i&lt;infix_expr.length; i++){
			if(Character.isDigit(infix_expr[i])){
				String read_num = "" + infix_expr[i] ; 			
				int j = i ;
				while(Character.isDigit(infix_expr[++j])){
					read_num = read_num + infix_expr[j] ;
				}
				i = j - 1 ;
				postfix.add(read_num) ;
			}else{
				if(Character.compare(infix_expr[i], '(') == 0)
					operator_stack.push('(') ;
				else if(Character.compare(infix_expr[i], ')') == 0){
					while(!operator_stack.peek().equals('(')){
						postfix.add("" + operator_stack.pop()) ;
					}
					operator_stack.pop() ;
				}else{
					if(InfixExpressionEvaluate.compare(infix_expr[i], operator_stack.peek()) == 1){
						operator_stack.push(infix_expr[i]) ;
					}else{
						if(InfixExpressionEvaluate.compare(infix_expr[i], operator_stack.peek()) == -1){
							postfix.add("" + operator_stack.pop()) ;
							i -- ;
						}
					}
				}
			}
		}
		return postfix ;
	}


	public static int evaluate(String[] postfix){
		Stack&lt;Integer&gt; compute = new Stack&lt;Integer&gt;() ;
		for(int i=0; i&lt;postfix.length; i++){
			if(isDigit(postfix[i])){
				compute.push(Integer.parseInt(postfix[i])) ;
			}else{
				switch(postfix[i]){
					case "!":
						int fac = compute.pop() ;
						compute.push(InfixExpressionEvaluate.factorial(fac)) ; 
						break ;
					default:  
						int first = compute.pop() ;
						int following = compute.pop() ;
						compute.push(InfixExpressionEvaluate.operate(postfix[i].toCharArray()[0], first, following)) ;
				}
			}
		}			
		return compute.pop() ;
	}

	public static boolean isDigit(String s){
		try{
			Integer.parseInt(s) ;
			return true ;
		}catch(Exception e){
			return false ;
		}
	}
	

	public static void main(String args[]){
		String infix_expression = "(1+2^3!-4)*(5!-(6-(7-(89-0!))))" ;
		char[] infix_char = infix_expression.concat(")").toCharArray() ;
		List&lt;String&gt; postfix = infixToPostfix(infix_char) ;
		System.out.println(postfix) ;

		String[] str = new String[postfix.size()] ;
		Iterator&lt;String&gt; iter = postfix.iterator() ;
		int i = 0 ;
		while(iter.hasNext()){
			str[i++] = iter.next() ;	
		}	
		System.out.println(evaluate(str)) ;
	}
}/* output:
[1, 2, 3, !, ^, +, 4, -, 5, !, 6, 7, 89, 0, !, -, -, -, -, *]
2013
[Finished in 0.7s]
*/
</code></pre></div></div>

<p><strong>A Linked-List Stack Implementation</strong></p>

<p>LinearNode.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">作为</span><span class="n">Stack</span><span class="err">的</span><span class="n">field</span><span class="err">使用</span>
 <span class="p">*</span> <span class="err">包含一个</span><span class="n">data</span><span class="err">和</span><span class="n">preference</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span> <span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">LinearNode</span><span class="p">{</span>
	<span class="k">public</span> <span class="n">LinearNode</span> <span class="k">next</span> <span class="p">;</span>
	<span class="k">public</span> <span class="n">Object</span> <span class="n">data</span> <span class="p">;</span>

	<span class="k">public</span> <span class="n">LinearNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">){</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">o</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">LinearNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">,</span> <span class="n">LinearNode</span> <span class="n">nxt</span><span class="p">){</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">o</span> <span class="p">;</span>
		<span class="k">next</span> <span class="p">=</span> <span class="n">nxt</span> <span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Stack.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">/*</span>
 <span class="p">*</span> <span class="err">通过</span><span class="n">link</span><span class="p">-</span><span class="n">list</span><span class="err">的方式实现了</span><span class="n">Stack</span><span class="err">的数据结构</span>
 <span class="p">*/</span>
<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">Stack</span><span class="p">{</span>
	<span class="n">protected</span> <span class="n">LinearNode</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">protected</span> <span class="n">int</span> <span class="n">numItems</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>


	<span class="k">public</span> <span class="n">Stack</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="n">clear</span><span class="p">(){</span>
		<span class="n">head</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="k">boolean</span> <span class="n">isEmpty</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">==</span> <span class="m">0</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Object</span> <span class="n">pop</span><span class="p">(){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span>
			<span class="n">return</span> <span class="n">null</span><span class="p">;</span>
		<span class="n">Object</span> <span class="n">element</span> <span class="p">=</span> <span class="n">head</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
		<span class="n">head</span> <span class="p">=</span> <span class="n">head</span><span class="p">.</span><span class="k">next</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">--</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">element</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">push</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span>
			<span class="n">head</span> <span class="p">=</span> <span class="n">new</span> <span class="n">LinearNode</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">else</span>
			<span class="n">head</span> <span class="p">=</span> <span class="n">new</span> <span class="n">LinearNode</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">int</span> <span class="n">size</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Object</span> <span class="n">top</span><span class="p">(){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span>
			<span class="n">return</span> <span class="n">null</span><span class="p">;</span>
		<span class="n">return</span> <span class="n">head</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><strong>递归(Recursion)</strong></p>

<blockquote>
  <p>A variable to any running program is stack called the run-time stack. If the program in question takes the form of machine code, i.e., if the program was written in a truly compiled language, then the run-time stack is part of the running program. Java is not a truly compiled language; a java class file contains not machine code but byte code. Byte code is a language intermediate between Java and machine language. Java byte code cannot be executed directly by the CPU; byte code must be interperted, i.e., executed by a machine-language program. The machine-language program that executes Java byte code is called the Java Virtual Machine(JVM). The run-time stack available to a Java program resides within the JVM.</p>
</blockquote>

<blockquote>
  <p>When a methon is called, the method’s arguements and its return address are pushed onto the run-time stack before execution of the methon begins. A methon’s return address marks the location at which program execution should continue after the methon has returned. The methon’s arguements, its return address, and any other pertinent data that have been pushed onto the run-time stack are collectively refered to as the method call’s stack frame, or call frame, or activation record.</p>
</blockquote>

<p>Looping and recursion are equivalent, i.e., any algorithm that can be implemented with a loop can also be implemented with recursion, and vice versa.</p>

<p>The primary advantage of recursion is that it often means less work for the programmer. The drawback of it is that building and removing cll frames is time comsuming relative to the record keeping repuired by loops, and another is stack overflow.</p>

<hr />

<h3 id="3.2">3.2 队列(Queue)</h3>

<blockquote>
  <p>我们经常使用单链表(singly linked list)来实现栈数据结构，我们也可以使用单链表来实现队列。但是我们经常使用双链表(double linked list)来实现队列。一个link用来储存node的前面一个node地址(predecessor)，另外一个link用来储存node的后面一个node地址(Successor)</p>
</blockquote>

<p>DLNode.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">DLNode</span> <span class="n">extends</span> <span class="n">SLNode</span> <span class="p">{</span>

	<span class="n">DLNode</span> <span class="n">prev</span><span class="p">;</span>

	<span class="k">public</span> <span class="n">DLNode</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">DLNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">dat</span><span class="p">){</span>
		<span class="n">super</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">pre</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">nxt</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">DLNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">dat</span><span class="p">,</span> <span class="n">DLNode</span> <span class="n">pre</span><span class="p">,</span> <span class="n">DLNode</span> <span class="n">nxt</span><span class="p">){</span>
		<span class="n">super</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">nxt</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">prev</span> <span class="p">=</span> <span class="n">pre</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>SLNode.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">SLNode</span> <span class="p">{</span>

	<span class="k">public</span> <span class="n">Object</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">public</span> <span class="n">SLNode</span> <span class="k">next</span><span class="p">;</span>

	<span class="k">public</span> <span class="n">SLNode</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>

	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">SLNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">dat</span><span class="p">){</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">dat</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">nxt</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">SLNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">dat</span><span class="p">,</span> <span class="n">SLNode</span> <span class="n">nxt</span><span class="p">){</span>
		<span class="n">data</span> <span class="p">=</span> <span class="n">dat</span> <span class="p">;</span>
		<span class="k">next</span> <span class="p">=</span> <span class="n">nxt</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>这里的 SLNode 指的是上文中的 LinearNode</p>
</blockquote>

<p>Queue.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">Queue</span><span class="p">{</span> 

	<span class="n">DLNode</span> <span class="n">head</span><span class="p">;</span>
	<span class="n">DLNode</span> <span class="n">tail</span><span class="p">;</span>
	<span class="n">int</span> <span class="n">numItems</span><span class="p">;</span>

	<span class="k">public</span> <span class="n">Queue</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="n">clear</span><span class="p">(){</span>
		<span class="n">head</span> <span class="p">=</span> <span class="n">tail</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Object</span> <span class="n">front</span><span class="p">(){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span>
			<span class="n">return</span> <span class="n">null</span><span class="p">;</span>
		<span class="n">return</span> <span class="n">head</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">insertBack</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">()){</span>
			<span class="n">head</span> <span class="p">=</span> <span class="n">tail</span> <span class="p">=</span> <span class="n">new</span> <span class="n">DLNode</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
			<span class="n">return</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">tail</span><span class="p">.</span><span class="k">next</span> <span class="p">=</span> <span class="n">new</span> <span class="n">DLNode</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">tail</span> <span class="p">=</span> <span class="p">(</span><span class="n">DLNode</span><span class="p">)</span><span class="n">tail</span><span class="p">.</span><span class="k">next</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="k">boolean</span> <span class="n">isEmpty</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">==</span> <span class="m">0</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Object</span> <span class="n">removeFront</span><span class="p">(){</span>
		<span class="n">Object</span> <span class="n">tmp</span> <span class="p">=</span> <span class="n">front</span><span class="p">()</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span><span class="p">;</span>
		<span class="n">head</span> <span class="p">=</span> <span class="p">(</span><span class="n">DLNode</span><span class="p">)</span><span class="n">head</span><span class="p">.</span><span class="k">next</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">head</span> <span class="c1">!= null)
</span>			<span class="p">((</span><span class="n">DLNode</span><span class="p">)</span><span class="n">head</span><span class="p">).</span><span class="n">prev</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">else</span>
			<span class="n">tail</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">--</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">tmp</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">int</span> <span class="n">size</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">numItems</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><strong>队列的应用</strong></p>

<p>Queues are typically used to avoid loss in situations where congestion is possible, i.e., when request for some resource may arrive faster than they can be servied. A printer is an example of such resource; you may have heared the term print queue. A print queue holds pending print jobs in the order of the arrival. Queues are also used in computer simulations.</p>

<hr />

<h3 id="3.3">3.3 双向队列(Deque)</h3>

<blockquote>
  <p>A deque(pronounced “deck”) is a double-ended queue.</p>
</blockquote>

<p>Deque.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>


<span class="k">public</span> <span class="n">class</span> <span class="n">Deque</span> <span class="n">extends</span> <span class="n">Queue</span> <span class="p">{</span>

	<span class="k">public</span> <span class="n">Deque</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Object</span> <span class="n">back</span><span class="p">(){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">())</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">tail</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">element</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">insertFront</span><span class="p">(</span><span class="n">Object</span> <span class="n">element</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">isEmpty</span><span class="p">()){</span>
			<span class="n">insertBack</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
			<span class="n">return</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">head</span> <span class="p">=</span> <span class="n">new</span> <span class="n">DLNode</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">null</span><span class="p">,</span> <span class="p">(</span><span class="n">DLNode</span><span class="p">)</span><span class="n">head</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">head</span><span class="p">.</span><span class="k">next</span> <span class="c1">!= null)
</span>			<span class="p">((</span><span class="n">DLNode</span><span class="p">)</span><span class="n">head</span><span class="p">.</span><span class="k">next</span><span class="p">).</span><span class="n">prev</span> <span class="p">=</span> <span class="p">(</span><span class="n">DLNode</span><span class="p">)</span><span class="n">head</span> <span class="p">;</span>
		<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Object</span> <span class="n">removeback</span><span class="p">(){</span>
		<span class="n">Object</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">back</span><span class="p">()</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">temp</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">tail</span> <span class="p">=</span> <span class="n">tail</span><span class="p">.</span><span class="n">prev</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">tail</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">head</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">else</span><span class="p">{</span>
			<span class="p">((</span><span class="n">DLNode</span><span class="p">)</span><span class="n">tail</span><span class="p">.</span><span class="k">next</span><span class="p">).</span><span class="n">prev</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
			<span class="n">tail</span><span class="p">.</span><span class="k">next</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">numItems</span> <span class="p">--</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">temp</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><strong>Deque Application</strong></p>

<p>One application of deque is storing a web browser’s history. Recently visited URLs are added to the front of the deque, and the URL at the back of the deque is removed after some specified number of insertions at the front.</p>

<hr />

<h3 id="3.4">3.4 通用二叉树(General Binary Tree)</h3>

<blockquote>
  <p>To traverse a binary tree is to visit each of the tree’s node.</p>
</blockquote>

<ul>
  <li>A preorder traversal visits a given node before visiting either of the node’s children(and their subtrees).</li>
  <li>An inorder traversal visits a given node’s left child(ant the left child’s subtree), then the node itself, then the node’s right child(and the right child’s subtree).</li>
  <li>A postorder traversal visits a given node’s two subtree before visiting the node itself.</li>
</ul>

<p><strong>Binary Tree Implementation</strong></p>

<p>TreeContainer.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>


<span class="k">public</span> <span class="n">abstract</span> <span class="n">class</span> <span class="n">TreeContainer</span> <span class="n">extends</span> <span class="n">LinkedContainer</span> <span class="p">{</span>

	<span class="n">protected</span> <span class="n">Node</span> <span class="n">root</span><span class="p">;</span>

	<span class="k">public</span> <span class="n">TreeContainer</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="n">clear</span><span class="p">(){</span>
		<span class="n">root</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>BinaryTree.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>


<span class="k">public</span> <span class="n">abstract</span> <span class="n">class</span> <span class="n">BinaryTree</span> <span class="n">extends</span> <span class="n">TreeContainer</span> <span class="p">{</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">abstract</span> <span class="n">class</span> <span class="n">BinaryTreeNode</span> <span class="n">extends</span> <span class="n">Node</span> <span class="p">{</span>

		<span class="k">public</span> <span class="n">BinaryTreeNode</span> <span class="n">leftChild</span><span class="p">;</span>
		<span class="k">public</span> <span class="n">BinaryTreeNode</span> <span class="n">parent</span><span class="p">;</span>
		<span class="k">public</span> <span class="n">BinaryTreeNode</span> <span class="n">rightChild</span><span class="p">;</span>

		
		<span class="p">/**</span>
	 	<span class="p">-</span> 
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
		 <span class="p">*/</span>
		<span class="k">public</span> <span class="n">BinaryTreeNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">dat</span><span class="p">){</span>
			<span class="n">super</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>

		<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
			<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="p">/**</span>
	 	<span class="p">-</span> 
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">lc</span>
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">rc</span>
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">par</span>
		 <span class="p">*/</span>
		<span class="k">public</span> <span class="n">BinaryTreeNode</span><span class="p">(</span><span class="n">Object</span> <span class="n">dat</span><span class="p">,</span> <span class="n">BinaryTreeNode</span> <span class="n">lc</span><span class="p">,</span> <span class="n">BinaryTreeNode</span> <span class="n">rc</span><span class="p">,</span> <span class="n">BinaryTreeNode</span> <span class="n">par</span><span class="p">){</span>
			<span class="n">super</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">leftChild</span> <span class="p">=</span> <span class="n">lc</span> <span class="p">;</span>
			<span class="n">rightChild</span> <span class="p">=</span> <span class="n">rc</span> <span class="p">;</span>
			<span class="n">parent</span> <span class="p">=</span> <span class="n">par</span> <span class="p">;</span>	
		<span class="p">}</span>

		<span class="k">public</span> <span class="k">boolean</span> <span class="n">isLeaf</span><span class="p">(){</span>
			<span class="n">return</span> <span class="n">leftChild</span><span class="p">==</span><span class="n">null</span> <span class="p">&amp;&amp;</span> <span class="n">rightChild</span><span class="p">==</span><span class="n">null</span> <span class="p">;</span>
		<span class="p">}</span>


	<span class="p">}</span>

	<span class="k">public</span> <span class="n">interface</span> <span class="n">NodeProcessor</span> <span class="p">{</span>

		<span class="p">/**</span>
	 	<span class="p">-</span> 
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">node</span>
		 <span class="p">*/</span>
		<span class="n">void</span> <span class="n">processNode</span><span class="p">(</span><span class="n">BinaryTreeNode</span> <span class="n">node</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">BinaryTree</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">int</span> <span class="n">height</span><span class="p">(){</span>
		<span class="n">return</span> <span class="n">heightHelper</span><span class="p">((</span><span class="n">BinaryTreeNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">current</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">ht</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">int</span> <span class="n">heightHelper</span><span class="p">(</span><span class="n">BinaryTreeNode</span> <span class="n">current</span><span class="p">,</span> <span class="n">int</span> <span class="n">ht</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">ht</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">Math</span><span class="p">.</span><span class="k">max</span><span class="p">(</span><span class="n">heightHelper</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">ht</span><span class="p">+</span><span class="m">1</span><span class="p">),</span>
						<span class="n">heightHelper</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">ht</span><span class="p">+</span><span class="m">1</span><span class="p">))</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">node</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">processor</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">void</span> <span class="n">inorder</span><span class="p">(</span><span class="n">BinaryTreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">NodeProcessor</span> <span class="n">processor</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="c1">!= null)
</span>			<span class="n">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
		<span class="n">processor</span><span class="p">.</span><span class="n">processNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="c1">!= null)
</span>			<span class="n">inorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">processor</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">inorderTraverse</span><span class="p">(</span><span class="n">NodeProcessor</span> <span class="n">processor</span><span class="p">){</span>
		<span class="n">inorder</span><span class="p">((</span><span class="n">BinaryTreeNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">node</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">processor</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">void</span> <span class="n">postorder</span><span class="p">(</span><span class="n">BinaryTreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">NodeProcessor</span> <span class="n">processor</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="c1">!= null){
</span>			<span class="n">postorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">postorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">processor</span><span class="p">.</span><span class="n">processNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">processor</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">postorderTraverse</span><span class="p">(</span><span class="n">NodeProcessor</span> <span class="n">processor</span><span class="p">){</span>
		<span class="n">postorder</span><span class="p">((</span><span class="n">BinaryTreeNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">node</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">processor</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">void</span> <span class="n">preorder</span><span class="p">(</span><span class="n">BinaryTreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">NodeProcessor</span> <span class="n">processor</span><span class="p">){</span>
		<span class="n">processor</span><span class="p">.</span><span class="n">processNode</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">node</span> <span class="c1">!= null){
</span>			<span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">node</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">processor</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">preorderTraverse</span><span class="p">(</span><span class="n">BinaryTreeNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">NodeProcessor</span> <span class="n">processor</span><span class="p">){</span>
		<span class="n">preorder</span><span class="p">((</span><span class="n">BinaryTreeNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">processor</span><span class="p">)</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>Class BinaryTree extends TreeContainer and also contains static member class BinaryTreeNode, which subclass Node, and member interface NodeProcessor. Any class that realize interface NodeProcessor must offer a public method called processNode, which accepts an arguement of type of BinaryTreeNode. This gives our traversals great versatility; we can process all the nodes of a BinaryTree in any way we choose simply by coding a class that fulfills the contract set forth by the interface.</p>
</blockquote>

<p><strong>Binary Tree Application</strong></p>

<ul>
  <li>Huffman coding, which is used in data compression</li>
  <li>The expression tree</li>
  <li>The binary search tree(BST)</li>
</ul>

<hr />

<h3 id="3.5">3.5 Binary Search Tree</h3>

<blockquote>
  <p>A binary search tree(BST) is a totally ordered binary tree. The BST’s total ordering does the heap’s partial ordering one better; not only is there a relationship between heap’s partial ordering one node and its children, but there is also a definite relationship between the children. In a BST, the 
value of a node’s left child is less than the value of the node itself, and the value of a node’s right child is greater than or equal to the value of the node.</p>
</blockquote>

<p><strong>BST Implementation</strong></p>

<p>BinarySearchTree.java</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">fmz</span><span class="p">.</span><span class="n">container</span><span class="p">;</span>


<span class="k">public</span> <span class="n">class</span> <span class="n">BinarySearchTree</span> <span class="n">extends</span> <span class="n">BinaryTree</span> <span class="p">{</span>

	<span class="p">//</span> <span class="n">A</span> <span class="n">BST</span> <span class="n">needs</span> <span class="n">Comparable</span> <span class="n">nodes</span> <span class="n">because</span> <span class="n">a</span> <span class="n">BST</span> <span class="n">is</span> <span class="n">totally</span> <span class="n">ordered</span>

	<span class="k">public</span> <span class="n">static</span> <span class="n">class</span> <span class="n">BSTNode</span> <span class="n">extends</span> <span class="n">BinaryTreeNode</span> <span class="n">implements</span> <span class="n">Comparable</span> <span class="p">{</span>


		<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
			<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="p">/**</span>
	 	<span class="p">-</span> 
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
		 <span class="p">*/</span>
		<span class="k">public</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">Comparable</span> <span class="n">dat</span><span class="p">){</span>
			<span class="n">super</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>

		<span class="p">/**</span>
	 	<span class="p">-</span> 
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">dat</span>
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">lc</span>
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">rc</span>
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">par</span>
		 <span class="p">*/</span>
		<span class="k">public</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">Comparable</span> <span class="n">dat</span><span class="p">,</span> <span class="n">BSTNode</span> <span class="n">lc</span><span class="p">,</span> <span class="n">BSTNode</span> <span class="n">rc</span><span class="p">,</span> <span class="n">BSTNode</span> <span class="n">par</span><span class="p">){</span>
			<span class="n">super</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>

		<span class="p">/**</span>
	 	<span class="p">-</span> 
	 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">o</span>
		 <span class="p">*/</span>
		<span class="k">public</span> <span class="n">int</span> <span class="n">compareTo</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">){</span>
			<span class="n">return</span> <span class="p">((</span><span class="n">Comparable</span><span class="p">)</span><span class="n">data</span><span class="p">).</span><span class="n">compareTo</span><span class="p">(((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">o</span><span class="p">).</span><span class="n">data</span><span class="p">)</span> <span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">BinarySearchTree</span><span class="p">(){</span>

	<span class="p">}</span>

	<span class="k">public</span> <span class="n">void</span> <span class="nb">finalize</span><span class="p">()</span> <span class="n">throws</span> <span class="n">Throwable</span> <span class="p">{</span>
		<span class="n">super</span><span class="p">.</span><span class="nb">finalize</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">target</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">find</span><span class="p">(</span><span class="n">BSTNode</span> <span class="n">target</span><span class="p">){</span>
		<span class="n">BSTNode</span> <span class="n">found</span> <span class="p">=</span> <span class="n">findHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">new</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="p">;</span>

		<span class="k">if</span><span class="p">(</span><span class="n">found</span> <span class="p">==</span>  <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">found</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">current</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">target</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">BSTNode</span> <span class="n">findHelper</span><span class="p">(</span><span class="n">BSTNode</span> <span class="n">current</span><span class="p">,</span> <span class="n">BSTNode</span> <span class="n">target</span><span class="p">){</span>
		<span class="p">//</span> <span class="k">If</span> <span class="n">we</span> <span class="n">have</span> <span class="n">left</span> <span class="n">the</span> <span class="n">tree</span><span class="p">,</span> <span class="k">then</span> <span class="n">the</span> <span class="n">target</span> <span class="n">was</span> <span class="k">not</span> <span class="n">found</span>
		<span class="p">//</span> <span class="n">This</span> <span class="n">method</span> <span class="n">is</span> <span class="n">recusive</span>

		<span class="k">if</span><span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>

		<span class="p">//</span> <span class="k">If</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span> <span class="n">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">the</span> <span class="n">current</span> <span class="n">node</span><span class="p">,</span> <span class="k">then</span> <span class="n">turn</span> <span class="n">left</span>

		<span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">findHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">;</span>

		<span class="p">//</span> <span class="k">If</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span> <span class="n">is</span> <span class="n">greater</span> <span class="n">than</span> <span class="n">the</span> <span class="n">currnt</span> <span class="n">node</span><span class="p">,</span> <span class="k">then</span> <span class="n">turn</span> <span class="n">right</span>

		<span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">findHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">;</span>

		<span class="p">//</span> <span class="n">Otherwise</span> <span class="n">the</span> <span class="n">currnt</span> <span class="n">node</span> <span class="n">is</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span>

		<span class="n">return</span> <span class="n">current</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">newItem</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">Comparable</span> <span class="n">newItem</span><span class="p">){</span>
		<span class="n">root</span> <span class="p">=</span> <span class="n">insertHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">new</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">newItem</span><span class="p">))</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">current</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">newNode</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">BSTNode</span> <span class="n">insertHelper</span><span class="p">(</span><span class="n">BSTNode</span> <span class="n">current</span><span class="p">,</span> <span class="n">BSTNode</span> <span class="n">newNode</span><span class="p">){</span>
		<span class="p">//</span> <span class="k">If</span> <span class="n">we</span> <span class="n">have</span> <span class="n">found</span> <span class="n">the</span> <span class="n">correct</span> <span class="n">location</span> <span class="n">for</span> <span class="n">the</span> <span class="n">node</span><span class="p">,</span> <span class="k">then</span> <span class="n">return</span> <span class="n">the</span> <span class="n">reference</span> <span class="k">to</span> <span class="n">the</span> <span class="n">new</span> <span class="n">node</span><span class="p">,</span> <span class="n">linking</span> <span class="n">it</span> <span class="k">to</span> <span class="n">the</span> <span class="n">tree</span>
		<span class="p">//</span> <span class="n">This</span> <span class="n">method</span> <span class="n">is</span> <span class="n">recusive</span>

		<span class="k">if</span><span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">null</span><span class="p">){</span>
			<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
			<span class="n">return</span> <span class="n">newNode</span> <span class="p">;</span>
		<span class="p">}</span>

		<span class="p">//</span> <span class="k">If</span> <span class="n">the</span> <span class="n">new</span> <span class="n">node</span> <span class="n">is</span> <span class="n">less</span> <span class="n">than</span> <span class="n">the</span> <span class="n">current</span> <span class="n">node</span><span class="p">,</span> <span class="k">then</span> <span class="n">go</span> <span class="n">left</span>
		<span class="p">//</span> <span class="n">otherwise</span> <span class="n">go</span> <span class="n">right</span>

		<span class="k">if</span><span class="p">(</span><span class="n">newNode</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">){</span>
			<span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">=</span> <span class="n">insertHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">newNode</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="p">=</span> <span class="n">current</span> <span class="p">;</span>
		<span class="p">}</span><span class="k">else</span><span class="p">{</span>
			<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">=</span> <span class="n">insertHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">newNode</span><span class="p">)</span> <span class="p">;</span>
			<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="p">=</span> <span class="n">current</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">return</span> <span class="n">current</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">current</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">BSTNode</span> <span class="n">maxHelper</span><span class="p">(</span><span class="n">BSTNode</span> <span class="n">current</span><span class="p">){</span>
		<span class="p">//</span> <span class="n">This</span> <span class="n">method</span> <span class="n">is</span> <span class="k">not</span> <span class="n">recusive</span><span class="p">,</span> <span class="n">because</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">nodes</span> <span class="k">of</span> <span class="n">a</span> <span class="n">BST</span> <span class="n">is</span> <span class="n">easy</span> <span class="k">to</span> <span class="n">find</span> <span class="n">using</span> <span class="n">a</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">//</span> <span class="n">go</span> <span class="n">right</span> <span class="k">until</span> <span class="n">the</span> <span class="n">rightmost</span> <span class="n">node</span> <span class="k">if</span> <span class="n">found</span>

		<span class="k">if</span><span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="c1">!= null)
</span>			<span class="n">current</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">current</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">maximum</span><span class="p">(){</span>
		<span class="n">BSTNode</span> <span class="k">max</span> <span class="p">=</span> <span class="n">maxHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">root</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="k">max</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="k">max</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">current</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">BSTNode</span> <span class="n">minHelper</span><span class="p">(</span><span class="n">BSTNode</span> <span class="n">current</span><span class="p">){</span>
		<span class="p">//</span> <span class="n">This</span> <span class="n">minimum</span> <span class="n">node</span> <span class="k">of</span> <span class="n">a</span> <span class="n">BST</span> <span class="n">is</span> <span class="n">the</span> <span class="n">leftmost</span> <span class="n">node</span>

		<span class="k">if</span><span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="c1">!= null)
</span>			<span class="n">current</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">;</span>
		<span class="n">return</span> <span class="n">current</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">minimum</span><span class="p">(){</span>
		<span class="n">BSTNode</span> <span class="k">min</span> <span class="p">=</span> <span class="n">minHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">root</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="k">min</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="k">min</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/*</span>
 	<span class="p">-</span> <span class="n">The</span> <span class="n">inorder</span> <span class="n">predecessor</span> <span class="k">of</span> <span class="n">node</span> <span class="n">n</span> <span class="n">is</span>
 	<span class="p">-</span> <span class="m">1.</span> <span class="n">the</span> <span class="n">maximum</span> <span class="n">node</span> <span class="k">of</span> <span class="n">n</span><span class="s1">'s left subtree, provided that n has a left subtree
 	- 2. the first ancessor of n such that n is in the ancessor'</span><span class="n">s</span> <span class="n">right</span> <span class="n">subtree</span>
	 <span class="p">*/</span> 

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">target</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">predecessor</span><span class="p">(</span><span class="n">Comparable</span> <span class="n">target</span><span class="p">){</span>
		<span class="n">BSTNode</span> <span class="n">found</span> <span class="p">=</span> <span class="n">findHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">new</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">.</span><span class="n">leftChild</span> <span class="c1">!= null)
</span>			<span class="n">return</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">maxHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">found</span><span class="p">.</span><span class="n">leftChild</span><span class="p">).</span><span class="n">data</span> <span class="p">;</span>
		<span class="n">BSTNode</span> <span class="n">parent</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">found</span><span class="p">.</span><span class="n">parent</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">parent</span> <span class="c1">!= null &amp;&amp; parent.compareTo(found) &gt; 0)
</span>			<span class="n">parent</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">parent</span><span class="p">.</span><span class="n">parent</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">parent</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">parent</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">target</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">void</span> <span class="n">remove</span><span class="p">(</span><span class="n">Comparable</span> <span class="n">target</span><span class="p">){</span>
		<span class="n">removeHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">new</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/*</span>
 	<span class="p">-</span> <span class="m">1.</span> <span class="n">Find</span> <span class="n">the</span> <span class="n">node</span> <span class="k">to</span> <span class="n">be</span> <span class="n">removed</span><span class="p">.</span> <span class="k">If</span> <span class="n">no</span> <span class="n">such</span> <span class="n">node</span> <span class="nb">exists</span><span class="p">,</span> <span class="n">terminate</span><span class="p">.</span>
 	<span class="p">-</span> <span class="m">2.</span>  <span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">if</span><span class="p">(</span><span class="n">the</span> <span class="n">node</span> <span class="k">to</span> <span class="n">be</span> <span class="n">removed</span> <span class="n">is</span> <span class="n">a</span> <span class="n">leaf</span><span class="p">)</span>
	 			<span class="k">If</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span> <span class="n">has</span> <span class="n">a</span> <span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">e</span><span class="p">.,</span> <span class="k">if</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span> <span class="n">is</span> <span class="k">not</span> <span class="n">the</span> <span class="n">root</span><span class="p">,</span> <span class="k">then</span> <span class="n">overwrite</span> <span class="n">the</span> <span class="n">parent</span><span class="s1">'s reference to the target node
	 			with null, unlinking the target node from the tree.
	 	   (2) else if(the target node has no left child)
	 	   		Overwirte the target node'</span><span class="n">s</span> <span class="n">data</span> <span class="n">portion</span> <span class="k">and</span> <span class="n">the</span> <span class="n">links</span> <span class="k">to</span> <span class="n">its</span> <span class="n">children</span> <span class="k">with</span> <span class="n">those</span> <span class="k">of</span> <span class="n">its</span> <span class="n">right</span> <span class="n">child</span><span class="p">,</span> <span class="n">effectively</span> <span class="n">transforming</span> <span class="n">the</span>
	 	   		<span class="n">node</span> <span class="n">into</span> <span class="n">its</span> <span class="n">right</span> <span class="n">child</span><span class="p">.</span>
	 	   <span class="p">(</span><span class="m">3</span><span class="p">)</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">the</span> <span class="n">target</span> <span class="n">node</span> <span class="n">has</span> <span class="n">no</span> <span class="n">right</span> <span class="n">child</span><span class="p">)</span>
	 	   		<span class="n">Transform</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span> <span class="n">into</span> <span class="n">its</span> <span class="n">left</span> <span class="n">child</span><span class="p">.</span>
	 	   <span class="p">(</span><span class="m">4</span><span class="p">)</span> <span class="k">else</span> <span class="p">//</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span> <span class="n">has</span> <span class="n">two</span> <span class="n">childern</span>
				<span class="n">Replace</span> <span class="n">the</span> <span class="n">target</span> <span class="n">node</span><span class="s1">'s data portion with that of its successor, which is the minimum node of the target node'</span><span class="n">s</span> <span class="n">right</span> <span class="n">subtree</span><span class="p">.</span> <span class="k">Then</span>
				<span class="n">delete</span> <span class="n">the</span> <span class="n">successor</span><span class="p">,</span> <span class="k">to</span> <span class="n">which</span> <span class="k">case</span> <span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="k">or</span> <span class="k">case</span> <span class="p">(</span><span class="m">2</span><span class="p">)</span> <span class="n">must</span> <span class="n">apply</span><span class="p">.</span>
	 <span class="p">*/</span>

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">current</span>
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">target</span>
	 <span class="p">*/</span>
	<span class="n">protected</span> <span class="n">BSTNode</span> <span class="n">removeHelper</span><span class="p">(</span><span class="n">BSTNode</span> <span class="n">current</span><span class="p">,</span> <span class="n">BSTNode</span> <span class="n">target</span><span class="p">){</span>
		<span class="k">if</span><span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">=</span> <span class="n">removeHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
			<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">=</span> <span class="n">removeHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="p">;</span>
		<span class="k">else</span><span class="p">{</span>
			<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">isLeaf</span><span class="p">()){</span>
				<span class="n">numItems</span> <span class="p">--</span> <span class="p">;</span>
				<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="n">BSTNode</span> <span class="n">temp</span> <span class="p">;</span>
			<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">==</span> <span class="n">null</span><span class="p">){</span>
				<span class="n">temp</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">;</span>
				<span class="n">current</span><span class="p">.</span><span class="n">data</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
				<span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="c1">!= null)
</span>					<span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="p">=</span> <span class="n">current</span> <span class="p">;</span>
				<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="c1">!= null)
</span>					<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="p">=</span> <span class="n">current</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">==</span> <span class="n">null</span><span class="p">){</span>
				<span class="n">temp</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">;</span>
				<span class="n">current</span><span class="p">.</span><span class="n">data</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
				<span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">leftChild</span> <span class="c1">!= null)
</span>					<span class="n">current</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">parent</span> <span class="p">=</span> <span class="n">current</span> <span class="p">;</span>
				<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="c1">!= null)
</span>					<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="p">=</span> <span class="n">current</span> <span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span><span class="p">{</span>
				<span class="n">temp</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">;</span>
				<span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">isLeaf</span><span class="p">()){</span>
					<span class="n">current</span><span class="p">.</span><span class="n">data</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
					<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">=</span> <span class="n">null</span> <span class="p">;</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">==</span> <span class="n">null</span><span class="p">){</span>
					<span class="n">current</span><span class="p">.</span><span class="n">data</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
					<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">rightChild</span> <span class="p">;</span>
					<span class="k">if</span><span class="p">(</span><span class="n">current</span><span class="p">.</span><span class="n">rightChild</span> <span class="c1">!= null)
</span>						<span class="n">current</span><span class="p">.</span><span class="n">rightChild</span><span class="p">.</span><span class="n">parent</span> <span class="p">=</span> <span class="n">current</span> <span class="p">;</span>
				<span class="p">}</span>
				<span class="k">else</span><span class="p">{</span>
					<span class="k">while</span><span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">leftChild</span> <span class="c1">!= null)
</span>						<span class="n">temp</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">temp</span><span class="p">.</span><span class="n">leftChild</span> <span class="p">;</span>
					<span class="n">current</span><span class="p">.</span><span class="n">data</span> <span class="p">=</span> <span class="n">temp</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
					<span class="n">removeHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">temp</span><span class="p">,</span> <span class="n">new</span> <span class="n">BSTNode</span><span class="p">((</span><span class="n">Comparable</span><span class="p">)</span><span class="n">temp</span><span class="p">.</span><span class="n">leftChild</span><span class="p">.</span><span class="n">data</span><span class="p">))</span> <span class="p">;</span>
					<span class="n">numItems</span> <span class="p">++</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">numItems</span> <span class="p">--</span> <span class="p">;</span>
		<span class="p">}</span>
		<span class="n">return</span> <span class="n">current</span> <span class="p">;</span>
	<span class="p">}</span>

	<span class="p">/*</span>
 	<span class="p">-</span> <span class="n">The</span> <span class="n">inorder</span> <span class="n">successor</span> <span class="k">of</span> <span class="n">node</span> <span class="n">n</span> <span class="n">is</span>
 	<span class="p">-</span> <span class="m">1.</span> <span class="n">the</span> <span class="n">minimum</span> <span class="n">node</span> <span class="k">of</span> <span class="n">n</span><span class="s1">'s right subtree, provided that n has a right subtree
 	- 2. the first ancessor of n such that n is in the ancessor'</span><span class="n">s</span> <span class="n">left</span> <span class="n">subtree</span>
	 <span class="p">*/</span> 

	<span class="p">/**</span>
 	<span class="p">-</span> 
 	<span class="p">-</span> <span class="p">@</span><span class="n">param</span> <span class="n">target</span>
	 <span class="p">*/</span>
	<span class="k">public</span> <span class="n">Comparable</span> <span class="n">successor</span><span class="p">(</span><span class="n">Comparable</span> <span class="n">target</span><span class="p">){</span>
		<span class="n">BSTNode</span> <span class="n">found</span> <span class="p">=</span> <span class="n">findHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">root</span><span class="p">,</span> <span class="n">new</span> <span class="n">BSTNode</span><span class="p">(</span><span class="n">target</span><span class="p">))</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">found</span><span class="p">.</span><span class="n">rightChild</span> <span class="c1">!= null)
</span>			<span class="n">return</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">minHelper</span><span class="p">((</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">found</span><span class="p">.</span><span class="n">rightChild</span><span class="p">).</span><span class="n">data</span> <span class="p">;</span>
		<span class="n">BSTNode</span> <span class="n">parent</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">found</span><span class="p">.</span><span class="n">parent</span> <span class="p">;</span>
		<span class="k">while</span><span class="p">(</span><span class="n">parent</span> <span class="c1">!= null &amp;&amp; parent.compareTo(found) &lt;= 0)
</span>			<span class="n">parent</span> <span class="p">=</span> <span class="p">(</span><span class="n">BSTNode</span><span class="p">)</span><span class="n">parent</span><span class="p">.</span><span class="n">parent</span> <span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">parent</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span>
			<span class="n">return</span> <span class="n">null</span> <span class="p">;</span>
		<span class="n">return</span> <span class="p">(</span><span class="n">Comparable</span><span class="p">)</span><span class="n">parent</span><span class="p">.</span><span class="n">data</span> <span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p><strong>Time Analysis of the Fundamental BST Operations</strong></p>

<blockquote>
  <p>A tree is said to be balanced, if the tree has the least possible height.</p>
</blockquote>

<p>The height of a balenced binary tree with n nodes is approximately lg(n). The operatinos insert, find, and remove are all in O(lg(n))</p>

<p>In the worse case, however, operations insert, find, and remove are in O(n), for in the worse case a BST is simply a list.</p>

<p><strong>BST Application</strong></p>

<ul>
  <li>dictiorary</li>
</ul>

<hr />

<hr />

</div>

      <div class="footer">
        <div class="disclaimer">
  
  <p>
    The postings on this site are my own and I am only responsible for myself
  </p>
  

  <p>
    © 麦羞, 2017 &mdash; built with Jekyll based on Github
  </p>
</div>

      </div>
    </div>
  </div>


<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34087103-1']);
  
  _gaq.push(['_setDomainName', 'lenage.com']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


<script type="text/javascript" src="/blogs/assets/scripts/MathJax-2.0-min.js"></script>
<script type="text/javascript" src="/blogs/assets/scripts/jquery-1.11.3.min.js"></script>
<script>
  $(function(){
    var $category = $('ul#java-posts li:gt(8):not(:last)');
    $category.hide();
    var $toggleBtn=$('div.java-showmore > a') ;
    $toggleBtn.click(function(){
      if($category.is(":visible")){
            $category.hide() ;
            $('div.java-showmore a span')
              .text("More...") ;
          }else{
            $category.show() ;
            $('div.java-showmore a span')
            .text("Less") ;
          }
          return false ;
    })
  })

  $(function(){
    var $category = $('ul#diary-posts li:gt(8):not(:last)');
    $category.hide();
    var $toggleBtn=$('div.diary-showmore > a') ;
    $toggleBtn.click(function(){
      if($category.is(":visible")){
            $category.hide() ;
            $('div.diary-showmore a span')
              .text("More...") ;
          }else{
            $category.show() ;
            $('div.diary-showmore a span')
            .text("Less") ;
          }
          return false ;
    })
  })
</script>

</body>
</html>
